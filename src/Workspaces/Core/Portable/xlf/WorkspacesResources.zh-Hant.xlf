<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../WorkspacesResources.resx">
    <body>
      <trans-unit id="An_error_occurred_while_reading_the_specified_configuration_file_colon_0">
        <source>An error occurred while reading the specified configuration file: {0}</source>
        <target state="translated">讀取指定的組態檔時發生錯誤: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_0_is_not_from_source">
        <source>Symbol "{0}" is not from source.</source>
        <target state="translated">符號 "{0}" 非來自來源。</target>
        <note />
      </trans-unit>
      <trans-unit id="Documentation_comment_id_must_start_with_E_F_M_N_P_or_T">
        <source>Documentation comment id must start with E, F, M, N, P or T</source>
        <target state="translated">文件註解 ID 必須以 E、F、M、N、P 或 T 開頭</target>
        <note />
      </trans-unit>
      <trans-unit id="Cycle_detected_in_extensions">
        <source>Cycle detected in extensions</source>
        <target state="translated">在擴充功能中偵測到循環</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_but_given_one_is_1">
        <source>Destination type must be a {0}, but given one is {1}.</source>
        <target state="translated">目的地類型必須是 {0}，但提供的是 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_or_a_1_but_given_one_is_2">
        <source>Destination type must be a {0} or a {1}, but given one is {2}.</source>
        <target state="translated">目的地類型必須是 {0} 或 {1}，但提供的是 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_1_or_2_but_given_one_is_3">
        <source>Destination type must be a {0}, {1} or {2}, but given one is {3}.</source>
        <target state="translated">目的地類型必須是 {0}、{1} 或 {2}，但提供的是 {3}。</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_location_to_generation_symbol_into">
        <source>Could not find location to generation symbol into.</source>
        <target state="translated">找不到產生符號目的地位置。</target>
        <note />
      </trans-unit>
      <trans-unit id="No_location_provided_to_add_statements_to">
        <source>No location provided to add statements to.</source>
        <target state="translated">未提供加入陳述式的位置。</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_location_was_not_in_source">
        <source>Destination location was not in source.</source>
        <target state="translated">目的地位置不在來源中。</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_location_was_from_a_different_tree">
        <source>Destination location was from a different tree.</source>
        <target state="translated">目的地位置來自不同的樹狀目錄。</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_is_of_the_wrong_type">
        <source>Node is of the wrong type.</source>
        <target state="translated">節點類型不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="Location_must_be_null_or_from_source">
        <source>Location must be null or from source.</source>
        <target state="translated">位置必須是 null 或源自來源。</target>
        <note />
      </trans-unit>
      <trans-unit id="Duplicate_source_file_0_in_project_1">
        <source>Duplicate source file '{0}' in project '{1}'</source>
        <target state="translated">複製專案 '{1}' 中的原始程式檔 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_projects_is_not_supported">
        <source>Removing projects is not supported.</source>
        <target state="translated">不支援移除專案。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_projects_is_not_supported">
        <source>Adding projects is not supported.</source>
        <target state="translated">不支援新增專案。</target>
        <note />
      </trans-unit>
      <trans-unit id="Workspace_is_not_empty">
        <source>Workspace is not empty.</source>
        <target state="translated">工作區不是空的。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_part_of_the_workspace">
        <source>'{0}' is not part of the workspace.</source>
        <target state="translated">'{0}' 不是工作區的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_part_of_the_workspace">
        <source>'{0}' is already part of the workspace.</source>
        <target state="translated">'{0}' 已經是工作區的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_referenced">
        <source>'{0}' is not referenced.</source>
        <target state="translated">'未參考 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_referenced">
        <source>'{0}' is already referenced.</source>
        <target state="translated">'已經參考 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_project_reference_from_0_to_1_will_cause_a_circular_reference">
        <source>Adding project reference from '{0}' to '{1}' will cause a circular reference.</source>
        <target state="translated">將專案參考從 '{0}' 加入 '{1}' 會造成循環參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="Metadata_is_not_referenced">
        <source>Metadata is not referenced.</source>
        <target state="translated">未參考中繼資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="Metadata_is_already_referenced">
        <source>Metadata is already referenced.</source>
        <target state="translated">已參考中繼資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_present">
        <source>{0} is not present.</source>
        <target state="translated">{0} 不存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_present">
        <source>{0} is already present.</source>
        <target state="translated">{0} 已經存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_specified_document_is_not_a_version_of_this_document">
        <source>The specified document is not a version of this document.</source>
        <target state="translated">指定的文件不是此文件的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_language_0_is_not_supported">
        <source>The language '{0}' is not supported.</source>
        <target state="translated">不支援語言 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_already_contains_the_specified_project">
        <source>The solution already contains the specified project.</source>
        <target state="translated">此方案已經含有指定的專案。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_does_not_contain_the_specified_project">
        <source>The solution does not contain the specified project.</source>
        <target state="translated">此方案不包含指定的專案。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_project_already_references_the_target_project">
        <source>The project already references the target project.</source>
        <target state="translated">此專案已經參考目標專案。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_project_already_transitively_references_the_target_project">
        <source>The project already transitively references the target project.</source>
        <target state="translated">此專案已經以可轉移方式參考目標專案。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_already_contains_the_specified_document">
        <source>The solution already contains the specified document.</source>
        <target state="translated">此方案已含有指定的文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_does_not_contain_the_specified_document">
        <source>The solution does not contain the specified document.</source>
        <target state="translated">此方案不包含指定的文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="Temporary_storage_cannot_be_written_more_than_once">
        <source>Temporary storage cannot be written more than once.</source>
        <target state="translated">無法多次寫入暫時儲存區。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_open">
        <source>'{0}' is not open.</source>
        <target state="translated">'{0}' 未開啟。</target>
        <note />
      </trans-unit>
      <trans-unit id="A_language_name_cannot_be_specified_for_this_option">
        <source>A language name cannot be specified for this option.</source>
        <target state="translated">無法指定此選項的語言名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="A_language_name_must_be_specified_for_this_option">
        <source>A language name must be specified for this option.</source>
        <target state="translated">必須指定此選項的語言名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="File_was_externally_modified_colon_0">
        <source>File was externally modified: {0}.</source>
        <target state="translated">已在外部修改檔案: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="Unrecognized_language_name">
        <source>Unrecognized language name.</source>
        <target state="translated">無法辨認的語言名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="Can_t_resolve_metadata_reference_colon_0">
        <source>Can't resolve metadata reference: '{0}'.</source>
        <target state="translated">無法解析中繼資料參考: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="Can_t_resolve_analyzer_reference_colon_0">
        <source>Can't resolve analyzer reference: '{0}'.</source>
        <target state="translated">無法解析分析器參考: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_Project">
        <source>Invalid project block, expected "=" after Project.</source>
        <target state="translated">專案區塊無效，專案之後必須是 "="。</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_project_name">
        <source>Invalid project block, expected "," after project name.</source>
        <target state="translated">專案區塊無效，專案名稱之後必須是 ","。</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_project_path">
        <source>Invalid project block, expected "," after project path.</source>
        <target state="translated">專案區塊無效，專案路徑之後必須是 ","。</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_0">
        <source>Expected {0}.</source>
        <target state="translated">必須是 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_must_be_a_non_null_and_non_empty_string">
        <source>"{0}" must be a non-null and non-empty string.</source>
        <target state="translated">"{0}" 必須是非 null 和非空白的字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_header_colon_0">
        <source>Expected header: "{0}".</source>
        <target state="translated">預期的標頭: "{0}"。</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_end_of_file">
        <source>Expected end-of-file.</source>
        <target state="translated">預期的檔案結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_0_line">
        <source>Expected {0} line.</source>
        <target state="translated">必須要有 {0} 行。</target>
        <note />
      </trans-unit>
      <trans-unit id="This_submission_already_references_another_submission_project">
        <source>This submission already references another submission project.</source>
        <target state="translated">此提交作業已參考其他提交專案。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_still_contains_open_documents">
        <source>{0} still contains open documents.</source>
        <target state="translated">{0} 仍包含開啟中的文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_still_open">
        <source>{0} is still open.</source>
        <target state="translated">{0} 仍在開啟中。</target>
        <note />
      </trans-unit>
      <trans-unit id="An_element_with_the_same_key_but_a_different_value_already_exists">
        <source>An element with the same key but a different value already exists.</source>
        <target state="translated">已經有相同索引鍵但不同值的項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays_with_more_than_one_dimension_cannot_be_serialized">
        <source>Arrays with more than one dimension cannot be serialized.</source>
        <target state="translated">無法序列化包含多個維度的陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
        <source>Value too large to be represented as a 30 bit unsigned integer.</source>
        <target state="translated">值太大，無法呈現為 30 位元不帶正負號的整數。</target>
        <note />
      </trans-unit>
      <trans-unit id="Specified_path_must_be_absolute">
        <source>Specified path must be absolute.</source>
        <target state="translated">指定的路徑必須是絕對路徑。</target>
        <note />
      </trans-unit>
      <trans-unit id="Cast_is_redundant">
        <source>Cast is redundant.</source>
        <target state="translated">多餘的 Cast。</target>
        <note />
      </trans-unit>
      <trans-unit id="Name_can_be_simplified">
        <source>Name can be simplified.</source>
        <target state="translated">可以簡化名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_identifier">
        <source>Unknown identifier.</source>
        <target state="translated">未知的識別項。</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_generate_code_for_unsupported_operator_0">
        <source>Cannot generate code for unsupported operator '{0}'</source>
        <target state="translated">無法產生不受支援之運算子 '{0}' 的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_number_of_parameters_for_binary_operator">
        <source>Invalid number of parameters for binary operator.</source>
        <target state="translated">二元運算子的參數數目無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_number_of_parameters_for_unary_operator">
        <source>Invalid number of parameters for unary operator.</source>
        <target state="translated">一元運算子的參數數目無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="Absolute_path_expected">
        <source>Absolute path expected.</source>
        <target state="translated">必須是絕對路徑。</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language">
        <source>Cannot open project '{0}' because the file extension '{1}' is not associated with a language.</source>
        <target state="translated">無法開啟專案 '{0}'，因為副檔名 '{1}' 未與語言相關聯。</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_open_project_0_because_the_language_1_is_not_supported">
        <source>Cannot open project '{0}' because the language '{1}' is not supported.</source>
        <target state="translated">無法開啟專案 '{0}'，因為不支援語言 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_file_path_colon_0">
        <source>Invalid project file path: '{0}'</source>
        <target state="translated">專案檔路徑無效: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_solution_file_path_colon_0">
        <source>Invalid solution file path: '{0}'</source>
        <target state="translated">方案檔路徑無效: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Project_file_not_found_colon_0">
        <source>Project file not found: '{0}'</source>
        <target state="translated">找不到專案檔: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Solution_file_not_found_colon_0">
        <source>Solution file not found: '{0}'</source>
        <target state="translated">找不到方案檔: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Unmerged_change_from_project_0">
        <source>Unmerged change from project '{0}'</source>
        <target state="translated">取消合併專案 '{0}' 的變更</target>
        <note />
      </trans-unit>
      <trans-unit id="Added_colon">
        <source>Added:</source>
        <target state="translated">已加入:</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0">
        <source>Fix all '{0}'</source>
        <target state="translated">修正所有 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0_in_1">
        <source>Fix all '{0}' in '{1}'</source>
        <target state="translated">修正 '{1}' 中的所有 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0_in_Solution">
        <source>Fix all '{0}' in Solution</source>
        <target state="translated">修正方案中的所有 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="After_colon">
        <source>After:</source>
        <target state="translated">之後:</target>
        <note />
      </trans-unit>
      <trans-unit id="Before_colon">
        <source>Before:</source>
        <target state="translated">之前:</target>
        <note />
      </trans-unit>
      <trans-unit id="Removed_colon">
        <source>Removed:</source>
        <target state="translated">已移除:</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_CodePage_value_colon_0">
        <source>Invalid CodePage value: {0}</source>
        <target state="translated">無效的字碼頁值: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_additional_documents_is_not_supported">
        <source>Adding additional documents is not supported.</source>
        <target state="translated">不支援新增其他文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_analyzer_references_is_not_supported">
        <source>Adding analyzer references is not supported.</source>
        <target state="translated">不支援新增分析器參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_documents_is_not_supported">
        <source>Adding documents is not supported.</source>
        <target state="translated">不支援新增文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_metadata_references_is_not_supported">
        <source>Adding metadata references is not supported.</source>
        <target state="translated">不支援新增中繼資料參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_project_references_is_not_supported">
        <source>Adding project references is not supported.</source>
        <target state="translated">不支援新增專案參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_additional_documents_is_not_supported">
        <source>Changing additional documents is not supported.</source>
        <target state="translated">不支援變更其他文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_documents_is_not_supported">
        <source>Changing documents is not supported.</source>
        <target state="translated">不支援變更文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_project_properties_is_not_supported">
        <source>Changing project properties is not supported.</source>
        <target state="translated">不支援變更專案屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_additional_documents_is_not_supported">
        <source>Removing additional documents is not supported.</source>
        <target state="translated">不支援移除其他文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_analyzer_references_is_not_supported">
        <source>Removing analyzer references is not supported.</source>
        <target state="translated">不支援移除分析器參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_documents_is_not_supported">
        <source>Removing documents is not supported.</source>
        <target state="translated">不支援移除文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_metadata_references_is_not_supported">
        <source>Removing metadata references is not supported.</source>
        <target state="translated">不支援移除中繼資料參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_project_references_is_not_supported">
        <source>Removing project references is not supported.</source>
        <target state="translated">不支援移除專案參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace">
        <source>Service of type '{0}' is required to accomplish the task but is not available from the workspace.</source>
        <target state="translated">完成工作需要 '{0}' 類型的服務，但是無法從工作區取得。</target>
        <note />
      </trans-unit>
      <trans-unit id="Supplied_diagnostic_cannot_be_null">
        <source>Supplied diagnostic cannot be null.</source>
        <target state="translated">提供的診斷不可為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="At_least_one_diagnostic_must_be_supplied">
        <source>At least one diagnostic must be supplied.</source>
        <target state="translated">至少必須提供一項診斷。</target>
        <note />
      </trans-unit>
      <trans-unit id="Diagnostic_must_have_span_0">
        <source>Diagnostic must have span '{0}'</source>
        <target state="translated">診斷範圍必須涵蓋 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_deserialize_type_0">
        <source>Cannot deserialize type '{0}'.</source>
        <target state="translated">無法將類型 '{0}' 還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_serialize_type_0">
        <source>Cannot serialize type '{0}'.</source>
        <target state="translated">無法將類型 '{0}' 序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_type_0_is_not_understood_by_the_serialization_binder">
        <source>The type '{0}' is not understood by the serialization binder.</source>
        <target state="translated">序列化繫結器無法辨識類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1">
        <source>Label for node '{0}' is invalid, it must be within [0, {1}).</source>
        <target state="translated">節點 '{0}' 的標籤無效，它必須位於 [0, {1}) 內。</target>
        <note />
      </trans-unit>
      <trans-unit id="Matching_nodes_0_and_1_must_have_the_same_label">
        <source>Matching nodes '{0}' and '{1}' must have the same label.</source>
        <target state="translated">相符節點 '{0}' 與 '{1}' 必須具有相同標籤。</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_0_must_be_contained_in_the_new_tree">
        <source>Node '{0}' must be contained in the new tree.</source>
        <target state="translated">新的樹狀結構中必須包含節點 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_0_must_be_contained_in_the_old_tree">
        <source>Node '{0}' must be contained in the old tree.</source>
        <target state="translated">舊的樹狀結構中必須包含節點 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="The_member_0_is_not_declared_within_the_declaration_of_the_symbol">
        <source>The member '{0}' is not declared within the declaration of the symbol.</source>
        <target state="translated">符號的宣告中並未宣告成員 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_position_is_not_within_the_symbol_s_declaration">
        <source>The position is not within the symbol's declaration</source>
        <target state="translated">位置不在符號的宣告中。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_0_cannot_be_located_within_the_current_solution">
        <source>The symbol '{0}' cannot be located within the current solution.</source>
        <target state="translated">在目前的方案中找不到符號 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_compilation_options_is_not_supported">
        <source>Changing compilation options is not supported.</source>
        <target state="translated">不支援變更編譯選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_parse_options_is_not_supported">
        <source>Changing parse options is not supported.</source>
        <target state="translated">不支援變更剖析選項。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_node_is_not_part_of_the_tree">
        <source>The node is not part of the tree.</source>
        <target state="translated">這個節點不屬於樹狀結構的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="This_workspace_does_not_support_opening_and_closing_documents">
        <source>This workspace does not support opening and closing documents.</source>
        <target state="translated">這個工作區不支援開啟及關閉文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="Usage_colon">
        <source>Usage:</source>
        <target state="translated">使用方式:</target>
        <note />
      </trans-unit>
      <trans-unit id="Exceptions_colon">
        <source>Exceptions:</source>
        <target state="translated">例外狀況:</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_returned_an_uninitialized_ImmutableArray">
        <source>'{0}' returned an uninitialized ImmutableArray</source>
        <target state="translated">'{0}' 傳回未初始化的 ImmutableArray</target>
        <note />
      </trans-unit>
      <trans-unit id="Failure">
        <source>Failure</source>
        <target state="translated">失敗</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning">
        <source>Warning</source>
        <target state="translated">警告</target>
        <note />
      </trans-unit>
      <trans-unit id="Populate_switch">
        <source>Populate switch</source>
        <target state="translated">填入切換</target>
        <note />
      </trans-unit>
      <trans-unit id="Member_access_should_be_qualified">
        <source>Member access should be qualified.</source>
        <target state="translated">必須限定成員存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_braces_to_0_statement">
        <source>Add braces to '{0}' statement.</source>
        <target state="translated">為 '{0}' 陳述式加入大括號。</target>
        <note />
      </trans-unit>
      <trans-unit id="Options_did_not_come_from_Workspace">
        <source>Options did not come from Workspace</source>
        <target state="translated">選項並非來自工作工作區</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable">
        <source>Enable</source>
        <target state="translated">啟用</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable_and_ignore_future_errors">
        <source>Enable and ignore future errors</source>
        <target state="translated">啟用並忽略未來的錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_encountered_an_error_and_has_been_disabled">
        <source>'{0}' encountered an error and has been disabled.</source>
        <target state="translated">'{0}' 發生錯誤並已停用。</target>
        <note />
      </trans-unit>
      <trans-unit id="Show_Stack_Trace">
        <source>Show Stack Trace</source>
        <target state="translated">顯示堆疊追蹤</target>
        <note />
      </trans-unit>
      <trans-unit id="Stream_is_too_long">
        <source>Stream is too long.</source>
        <target state="translated">資料流過長。</target>
        <note />
      </trans-unit>
      <trans-unit id="Deserialization_reader_for_0_read_incorrect_number_of_values">
        <source>Deserialization reader for '{0}' read incorrect number of values.</source>
        <target state="translated">{0}' 的還原序列化讀取器所讀取的值數目不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="Pascal_Case">
        <source>Pascal Case</source>
        <target state="translated">Pascal 命名法的大小寫</target>
        <note />
      </trans-unit>
      <trans-unit id="Abstract_Method">
        <source>Abstract Method</source>
        <target state="translated">抽象方法</target>
        <note>{locked: abstract}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Async_Method">
        <source>Async Method</source>
        <target state="translated">非同步方法</target>
        <note>{locked: async}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Begins_with_I">
        <source>Begins with I</source>
        <target state="translated">以 I 開頭</target>
        <note>{locked:I}</note>
      </trans-unit>
      <trans-unit id="Class">
        <source>Class</source>
        <target state="translated">類別</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Delegate">
        <source>Delegate</source>
        <target state="translated">委派</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Enum">
        <source>Enum</source>
        <target state="translated">列舉</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Event">
        <source>Event</source>
        <target state="translated">事件</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Interface">
        <source>Interface</source>
        <target state="translated">介面</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Non_Field_Members">
        <source>Non-Field Members</source>
        <target state="translated">非欄位成員</target>
        <note>{locked:field}</note>
      </trans-unit>
      <trans-unit id="Private_Method">
        <source>Private Method</source>
        <target state="translated">私人方法</target>
        <note>{locked: private}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Private_or_Internal_Field">
        <source>Private or Internal Field</source>
        <target state="translated">私人或內部欄位</target>
        <note>{locked: private}{locked: internal}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Private_or_Internal_Static_Field">
        <source>Private or Internal Static Field</source>
        <target state="translated">私人或內部靜態欄位</target>
        <note>{locked: private}{locked: internal}{locked:static}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Property">
        <source>Property</source>
        <target state="translated">屬性</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Public_or_Protected_Field">
        <source>Public or Protected Field</source>
        <target state="translated">公用或受保護欄位</target>
        <note>{locked: public}{locked: protected}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Static_Field">
        <source>Static Field</source>
        <target state="translated">靜態欄位</target>
        <note>{locked:static}{locked:field} (unless the capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Static_Method">
        <source>Static Method</source>
        <target state="translated">靜態方法</target>
        <note>{locked: static}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Struct">
        <source>Struct</source>
        <target state="translated">結構</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Types">
        <source>Types</source>
        <target state="translated">類型</target>
        <note>{locked:types} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Method">
        <source>Method</source>
        <target state="translated">方法</target>
        <note>{locked:method} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Missing_prefix_colon_0">
        <source>Missing prefix: '{0}'</source>
        <target state="translated">遺漏前置詞: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Error">
        <source>Error</source>
        <target state="translated">錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="None">
        <source>None</source>
        <target state="translated">無</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_suffix_colon_0">
        <source>Missing suffix: '{0}'</source>
        <target state="translated">遺漏尾碼: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0">
        <source>These non-leading words must begin with an upper case letter: {0}</source>
        <target state="translated">非前置字組必須以大寫字母開頭: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Suggestion">
        <source>Suggestion</source>
        <target state="translated">建議</target>
        <note />
      </trans-unit>
      <trans-unit id="These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0">
        <source>These non-leading words must begin with a lowercase letter: {0}</source>
        <target state="translated">非前置字組必須以小寫字母開頭: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_cannot_contain_lower_case_characters_colon_0">
        <source>These words cannot contain lower case characters: {0}</source>
        <target state="translated">這些字組不可包含小寫字母: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_cannot_contain_upper_case_characters_colon_0">
        <source>These words cannot contain upper case characters: {0}</source>
        <target state="translated">這些字組不可包含大寫字母: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_must_begin_with_upper_case_characters_colon_0">
        <source>These words must begin with upper case characters: {0}</source>
        <target state="translated">這些字組必須包含大寫字母: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="The_first_word_0_must_begin_with_an_upper_case_character">
        <source>The first word, '{0}', must begin with an upper case character</source>
        <target state="translated">第一個字組 '{0}' 必須以大寫字母開頭</target>
        <note />
      </trans-unit>
      <trans-unit id="The_first_word_0_must_begin_with_a_lower_case_character">
        <source>The first word, '{0}', must begin with a lower case character</source>
        <target state="translated">第一個字組 '{0}' 必須以小寫字母開頭</target>
        <note />
      </trans-unit>
      <trans-unit id="File_0_size_of_1_exceeds_maximum_allowed_size_of_2">
        <source>File '{0}' size of {1} exceeds maximum allowed size of {2}</source>
        <target state="translated">檔案 '{0}' 的大小 {1} 超過允許的大小上限 {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_document_property_is_not_supported">
        <source>Changing document properties is not supported</source>
        <target state="translated">不支援變更文件屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_cannot_be_comments">
        <source>Alternation conditions cannot be comments</source>
        <target state="new">Alternation conditions cannot be comments</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_do_not_capture_and_cannot_be_named">
        <source>Alternation conditions do not capture and cannot be named</source>
        <target state="new">Alternation conditions do not capture and cannot be named</target>
        <note />
      </trans-unit>
      <trans-unit id="A_subtraction_must_be_the_last_element_in_a_character_class">
        <source>A subtraction must be the last element in a character class</source>
        <target state="new">A subtraction must be the last element in a character class</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_include_class_0_in_character_range">
        <source>Cannot include class \{0} in character range</source>
        <target state="new">Cannot include class \{0} in character range</target>
        <note />
      </trans-unit>
      <trans-unit id="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
        <source>Capture group numbers must be less than or equal to Int32.MaxValue</source>
        <target state="new">Capture group numbers must be less than or equal to Int32.MaxValue</target>
        <note />
      </trans-unit>
      <trans-unit id="Capture_number_cannot_be_zero">
        <source>Capture number cannot be zero</source>
        <target state="new">Capture number cannot be zero</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_backslash_at_end_of_pattern">
        <source>Illegal \ at end of pattern</source>
        <target state="new">Illegal \ at end of pattern</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_x_y_with_x_less_than_y">
        <source>Illegal {x,y} with x &gt; y</source>
        <target state="new">Illegal {x,y} with x &gt; y</target>
        <note />
      </trans-unit>
      <trans-unit id="Incomplete_character_escape">
        <source>Incomplete \p{X} character escape</source>
        <target state="new">Incomplete \p{X} character escape</target>
        <note />
      </trans-unit>
      <trans-unit id="Insufficient_hexadecimal_digits">
        <source>Insufficient hexadecimal digits</source>
        <target state="new">Insufficient hexadecimal digits</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_group_name_Group_names_must_begin_with_a_word_character">
        <source>Invalid group name: Group names must begin with a word character</source>
        <target state="new">Invalid group name: Group names must begin with a word character</target>
        <note />
      </trans-unit>
      <trans-unit id="Malformed">
        <source>malformed</source>
        <target state="new">malformed</target>
        <note />
      </trans-unit>
      <trans-unit id="Malformed_character_escape">
        <source>Malformed \p{X} character escape</source>
        <target state="new">Malformed \p{X} character escape</target>
        <note />
      </trans-unit>
      <trans-unit id="Malformed_named_back_reference">
        <source>Malformed \k&lt;...&gt; named back reference</source>
        <target state="new">Malformed \k&lt;...&gt; named back reference</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_control_character">
        <source>Missing control character</source>
        <target state="new">Missing control character</target>
        <note />
      </trans-unit>
      <trans-unit id="Nested_quantifier_0">
        <source>Nested quantifier {0}</source>
        <target state="new">Nested quantifier {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_enough_close_parens">
        <source>Not enough )'s</source>
        <target state="new">Not enough )'s</target>
        <note />
      </trans-unit>
      <trans-unit id="Quantifier_x_y_following_nothing">
        <source>Quantifier {x,y} following nothing</source>
        <target state="new">Quantifier {x,y} following nothing</target>
        <note />
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group">
        <source>reference to undefined group</source>
        <target state="new">reference to undefined group</target>
        <note />
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_name_0">
        <source>Reference to undefined group name {0}</source>
        <target state="new">Reference to undefined group name {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_number_0">
        <source>Reference to undefined group number {0}</source>
        <target state="new">Reference to undefined group number {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Too_many_bars_in_conditional_grouping">
        <source>Too many | in (?()|)</source>
        <target state="new">Too many | in (?()|)</target>
        <note />
      </trans-unit>
      <trans-unit id="Too_many_close_parens">
        <source>Too many )'s</source>
        <target state="new">Too many )'s</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_property">
        <source>Unknown property</source>
        <target state="new">Unknown property</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_property_0">
        <source>Unknown property '{0}'</source>
        <target state="new">Unknown property '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Unrecognized_control_character">
        <source>Unrecognized control character</source>
        <target state="new">Unrecognized control character</target>
        <note />
      </trans-unit>
      <trans-unit id="Unrecognized_escape_sequence_0">
        <source>Unrecognized escape sequence \{0}</source>
        <target state="new">Unrecognized escape sequence \{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Unrecognized_grouping_construct">
        <source>Unrecognized grouping construct</source>
        <target state="new">Unrecognized grouping construct</target>
        <note />
      </trans-unit>
      <trans-unit id="Unterminated_character_class_set">
        <source>Unterminated [] set</source>
        <target state="new">Unterminated [] set</target>
        <note />
      </trans-unit>
      <trans-unit id="Unterminated_regex_comment">
        <source>Unterminated (?#...) comment</source>
        <target state="new">Unterminated (?#...) comment</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_any_character_group_long">
        <source>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the s option, . matches any character.</source>
        <target state="new">The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the s option, . matches any character.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_any_character_group_short">
        <source>any character</source>
        <target state="new">any character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_backspace_character_long">
        <source>Matches a backspace character, \u0008</source>
        <target state="new">Matches a backspace character, \u0008</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_backspace_character_short">
        <source>backspace character</source>
        <target state="new">backspace character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_balancing_group_long">
        <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group. This grouping construct has the following format:

(?&lt;name1-name2&gt;subexpression)  

where name1 is the current group (optional), name2 is a previously defined group, and subexpression is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses name2 as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, name1 is empty.

Note

After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</source>
        <target state="new">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group. This grouping construct has the following format:

(?&lt;name1-name2&gt;subexpression)  

where name1 is the current group (optional), name2 is a previously defined group, and subexpression is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses name2 as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, name1 is empty.

Note

After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_balancing_group_short">
        <source>balancing group</source>
        <target state="new">balancing group</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_bell_character_long">
        <source>Matches a bell (alarm) character, \u0007</source>
        <target state="new">Matches a bell (alarm) character, \u0007</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_bell_character_short">
        <source>bell character</source>
        <target state="new">bell character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_carriage_return_character_long">
        <source>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</source>
        <target state="new">Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_carriage_return_character_short">
        <source>carriage-return character</source>
        <target state="new">carriage-return character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_contiguous_matches_long">
        <source>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</source>
        <target state="new">The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_contiguous_matches_short">
        <source>contiguous matches</source>
        <target state="new">contiguous matches</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_control_character_long">
        <source>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</source>
        <target state="new">Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_control_character_short">
        <source>control character</source>
        <target state="new">control character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_decimal_digit_character_long">
        <source>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</source>
        <target state="new">\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_decimal_digit_character_short">
        <source>decimal-digit character</source>
        <target state="new">decimal-digit character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_end_of_string_only_long">
        <source>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</source>
        <target state="new">The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_end_of_string_only_short">
        <source>end of string only</source>
        <target state="new">end of string only</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_end_of_string_or_before_ending_newline_long">
        <source>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

Note that \Z matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</source>
        <target state="new">The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

Note that \Z matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_end_of_string_or_before_ending_newline_short">
        <source>end of string or before ending newline</source>
        <target state="new">end of string or before ending newline</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_end_of_string_or_line_long">
        <source>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string.

If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line. Note that $ matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</source>
        <target state="new">The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string.

If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line. Note that $ matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_end_of_string_or_line_short">
        <source>end of string or line</source>
        <target state="new">end of string or line</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_escape_character_long">
        <source>Matches an escape character, \u001B</source>
        <target state="new">Matches an escape character, \u001B</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_escape_character_short">
        <source>escape character</source>
        <target state="new">escape character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_form_feed_character_long">
        <source>Matches a form-feed character, \u000C</source>
        <target state="new">Matches a form-feed character, \u000C</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_form_feed_character_short">
        <source>form-feed character</source>
        <target state="new">form-feed character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_group_options_long">
        <source>The following grouping construct applies or disables the specified options within a subexpression:

(?imnsx-imnsx: subexpression )

where subexpression is any valid regular expression pattern. For example, (?i-s:) turns on case insensitivity and disables single-line mode.

Note

You can specify options that apply to an entire regular expression rather than a subexpression by using a System.Text.RegularExpressions.Regex class constructor or a static method. You can also specify inline options that apply after a specific point in a regular expression by using the (?imnsx-imnsx) language construct.

The group options construct is not a capturing group. That is, although any portion of a string that is captured by subexpression is included in the match, it is not included in a captured group nor used to populate the GroupCollection object.</source>
        <target state="new">The following grouping construct applies or disables the specified options within a subexpression:

(?imnsx-imnsx: subexpression )

where subexpression is any valid regular expression pattern. For example, (?i-s:) turns on case insensitivity and disables single-line mode.

Note

You can specify options that apply to an entire regular expression rather than a subexpression by using a System.Text.RegularExpressions.Regex class constructor or a static method. You can also specify inline options that apply after a specific point in a regular expression by using the (?imnsx-imnsx) language construct.

The group options construct is not a capturing group. That is, although any portion of a string that is captured by subexpression is included in the match, it is not included in a captured group nor used to populate the GroupCollection object.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_group_options_short">
        <source>group options</source>
        <target state="new">group options</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_hexadecimal_escape_long">
        <source>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</source>
        <target state="new">Matches an ASCII character, where ## is a two-digit hexadecimal character code.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_hexadecimal_escape_short">
        <source>hexidecimal escape</source>
        <target state="new">hexidecimal escape</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_letter_uppercase">
        <source>Letter, Uppercase</source>
        <target state="new">Letter, Uppercase</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_matched_subexpression_long">
        <source>The following grouping construct captures a matched subexpression:

( subexpression )

where subexpression is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.

Note

By default, the (subexpression) language element captures the matched subexpression. But if the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the matched subexpression is not captured.

You can access captured groups in four ways:

    By using the backreference construct within the regular expression. The matched subexpression is referenced in the same regular expression by using the syntax \number, where number is the ordinal number of the captured subexpression.

    By using the named backreference construct within the regular expression. The matched subexpression is referenced in the same regular expression by using the syntax \k&lt;name&gt;, where name is the name of a capturing group, or \k&lt;number&gt;, where number is the ordinal number of a capturing group. A capturing group has a default name that is identical to its ordinal number.

    By using the $number replacement sequence in a Regex.Replace or Match.Result method call, where number is the ordinal number of the captured subexpression.

    Programmatically, by using the GroupCollection object returned by the Match.Groups property. The member at position zero in the collection represents the entire regular expression match. Each subsequent member represents a matched subexpression.</source>
        <target state="new">The following grouping construct captures a matched subexpression:

( subexpression )

where subexpression is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.

Note

By default, the (subexpression) language element captures the matched subexpression. But if the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the matched subexpression is not captured.

You can access captured groups in four ways:

    By using the backreference construct within the regular expression. The matched subexpression is referenced in the same regular expression by using the syntax \number, where number is the ordinal number of the captured subexpression.

    By using the named backreference construct within the regular expression. The matched subexpression is referenced in the same regular expression by using the syntax \k&lt;name&gt;, where name is the name of a capturing group, or \k&lt;number&gt;, where number is the ordinal number of a capturing group. A capturing group has a default name that is identical to its ordinal number.

    By using the $number replacement sequence in a Regex.Replace or Match.Result method call, where number is the ordinal number of the captured subexpression.

    Programmatically, by using the GroupCollection object returned by the Match.Groups property. The member at position zero in the collection represents the entire regular expression match. Each subsequent member represents a matched subexpression.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_matched_subexpression_short">
        <source>matched subexpression</source>
        <target state="new">matched subexpression</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_name">
        <source>name</source>
        <target state="new">name</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_name1">
        <source>name1</source>
        <target state="new">name1</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_name2">
        <source>name2</source>
        <target state="new">name2</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_named_matched_subexpression_long">
        <source>The following grouping construct captures a matched subexpression and lets you access it by name or by number:

(?&lt;name&gt;subexpression)  

where name is a valid group name, and subexpression is any valid regular expression pattern. name must not contain any punctuation characters and cannot begin with a number.

Note

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.

You can access named captured groups in the following ways:

    By using the named backreference construct within the regular expression. The matched subexpression is referenced in the same regular expression by using the syntax \k&lt;name&gt;, where name is the name of the captured subexpression.

    By using the backreference construct within the regular expression. The matched subexpression is referenced in the same regular expression by using the syntax \number, where number is the ordinal number of the captured subexpression. Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.

    By using the ${name} replacement sequence in a Regex.Replace or Match.Result method call, where name is the name of the captured subexpression.

    By using the $number replacement sequence in a Regex.Replace or Match.Result method call, where number is the ordinal number of the captured subexpression.

    Programmatically, by using the GroupCollection object returned by the Match.Groups property. The member at position zero in the collection represents the entire regular expression match. Each subsequent member represents a matched subexpression. Named captured groups are stored in the collection after numbered captured groups.

    Programmatically, by providing the subexpression name to the GroupCollection object's indexer.</source>
        <target state="new">The following grouping construct captures a matched subexpression and lets you access it by name or by number:

(?&lt;name&gt;subexpression)  

where name is a valid group name, and subexpression is any valid regular expression pattern. name must not contain any punctuation characters and cannot begin with a number.

Note

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.

You can access named captured groups in the following ways:

    By using the named backreference construct within the regular expression. The matched subexpression is referenced in the same regular expression by using the syntax \k&lt;name&gt;, where name is the name of the captured subexpression.

    By using the backreference construct within the regular expression. The matched subexpression is referenced in the same regular expression by using the syntax \number, where number is the ordinal number of the captured subexpression. Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.

    By using the ${name} replacement sequence in a Regex.Replace or Match.Result method call, where name is the name of the captured subexpression.

    By using the $number replacement sequence in a Regex.Replace or Match.Result method call, where number is the ordinal number of the captured subexpression.

    Programmatically, by using the GroupCollection object returned by the Match.Groups property. The member at position zero in the collection represents the entire regular expression match. Each subsequent member represents a matched subexpression. Named captured groups are stored in the collection after numbered captured groups.

    Programmatically, by providing the subexpression name to the GroupCollection object's indexer.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_named_matched_subexpression_short">
        <source>named matched subexpression</source>
        <target state="new">named matched subexpression</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_negative_character_group_long">
        <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters may be specified individually, as a range, or both.

The syntax for specifying a list of individual characters is as follows:

[^character_group]

where character_group is a list of the individual characters that cannot appear in the input string for a match to succeed. character_group can consist of any combination of one or more literal characters, escape characters, or character classes.

The syntax for specifying a range of characters is as follows:

[^firstCharacter-lastCharacter]

where firstCharacter is the character that begins the range, and lastCharacter is the character that ends the range. A character range is a contiguous series of characters defined by specifying the first character in the series, a hyphen (-), and then the last character in the series. Two characters are contiguous if they have adjacent Unicode code points.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].

The leading carat character (^) in a negative character group is mandatory and indicates the character group is a negative character group instead of a positive character group.

Important

A negative character group in a larger regular expression pattern is not a zero-width assertion. That is, after evaluating the negative character group, the regular expression engine advances one character in the input string.</source>
        <target state="new">A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters may be specified individually, as a range, or both.

The syntax for specifying a list of individual characters is as follows:

[^character_group]

where character_group is a list of the individual characters that cannot appear in the input string for a match to succeed. character_group can consist of any combination of one or more literal characters, escape characters, or character classes.

The syntax for specifying a range of characters is as follows:

[^firstCharacter-lastCharacter]

where firstCharacter is the character that begins the range, and lastCharacter is the character that ends the range. A character range is a contiguous series of characters defined by specifying the first character in the series, a hyphen (-), and then the last character in the series. Two characters are contiguous if they have adjacent Unicode code points.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].

The leading carat character (^) in a negative character group is mandatory and indicates the character group is a negative character group instead of a positive character group.

Important

A negative character group in a larger regular expression pattern is not a zero-width assertion. That is, after evaluating the negative character group, the regular expression engine advances one character in the input string.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_negative_character_group_short">
        <source>negative character group</source>
        <target state="new">negative character group</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_negative_unicode_category_long">
        <source>The Unicode standard assigns each character a general category. For example, a particular character can be an uppercase letter (represented by the Lu category), a decimal digit (the Nd category), a math symbol (the Sm category), or a paragraph separator (the Zl category). Specific character sets in the Unicode standard also occupy a specific range or block of consecutive code points. For example, the basic Latin character set is found from \u0000 through \u007F, while the Arabic character set is found from \u0600 through \u06FF.

The regular expression construct

\P{ name }

matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="new">The Unicode standard assigns each character a general category. For example, a particular character can be an uppercase letter (represented by the Lu category), a decimal digit (the Nd category), a math symbol (the Sm category), or a paragraph separator (the Zl category). Specific character sets in the Unicode standard also occupy a specific range or block of consecutive code points. For example, the basic Latin character set is found from \u0000 through \u007F, while the Arabic character set is found from \u0600 through \u06FF.

The regular expression construct

\P{ name }

matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_negative_unicode_category_short">
        <source>negative unicode category</source>
        <target state="new">negative unicode category</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_new_line_character_long">
        <source>Matches a new-line character, \u000A</source>
        <target state="new">Matches a new-line character, \u000A</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_new_line_character_short">
        <source>new-line character</source>
        <target state="new">new-line character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_non_digit_character_long">
        <source>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</source>
        <target state="new">\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_non_digit_character_short">
        <source>non-digit character</source>
        <target state="new">non-digit character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_non_white_space_character_long">
        <source>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</source>
        <target state="new">\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_non_white_space_character_short">
        <source>non-white-space character</source>
        <target state="new">non-white-space character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_non_word_boundary_long">
        <source>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</source>
        <target state="new">The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_non_word_boundary_short">
        <source>non-word boundary</source>
        <target state="new">non-word boundary</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_non_word_character_long">
        <source>\W matches any non-word character. The \W language element is equivalent to the following character class:

[^\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]  

In other words, it matches any character except for those in the Unicode categories listed in the following table.

Ll 	Letter, Lowercase
Lu 	Letter, Uppercase
Lt 	Letter, Titlecase
Lo 	Letter, Other
Lm 	Letter, Modifier
Mn 	Mark, Nonspacing
Nd 	Number, Decimal Digit
Pc 	Punctuation, Connector. This category includes ten characters, the most commonly used of which is the LOWLINE character (_), u+005F.

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</source>
        <target state="new">\W matches any non-word character. The \W language element is equivalent to the following character class:

[^\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]  

In other words, it matches any character except for those in the Unicode categories listed in the following table.

Ll 	Letter, Lowercase
Lu 	Letter, Uppercase
Lt 	Letter, Titlecase
Lo 	Letter, Other
Lm 	Letter, Modifier
Mn 	Mark, Nonspacing
Nd 	Number, Decimal Digit
Pc 	Punctuation, Connector. This category includes ten characters, the most commonly used of which is the LOWLINE character (_), u+005F.

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_non_word_character_short">
        <source>non-word character</source>
        <target state="new">non-word character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_noncapturing_group_long">
        <source>The following grouping construct does not capture the substring that is matched by a subexpression:

(?:subexpression)  

where subexpression is any valid regular expression pattern. The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

Note

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
        <target state="new">The following grouping construct does not capture the substring that is matched by a subexpression:

(?:subexpression)  

where subexpression is any valid regular expression pattern. The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

Note

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_noncapturing_group_short">
        <source>noncapturing group</source>
        <target state="new">noncapturing group</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_positive_character_group_long">
        <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur. This list of characters may be specified individually, as a range, or both.

The syntax for specifying a list of individual characters is as follows:

[character_group]

where character_group is a list of the individual characters that can appear in the input string for a match to succeed. character_group can consist of any combination of one or more literal characters, escape characters, or character classes.

The syntax for specifying a range of characters is as follows:

[firstCharacter-lastCharacter]  

where firstCharacter is the character that begins the range and lastCharacter is the character that ends the range. A character range is a contiguous series of characters defined by specifying the first character in the series, a hyphen (-), and then the last character in the series. Two characters are contiguous if they have adjacent Unicode code points.</source>
        <target state="new">A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur. This list of characters may be specified individually, as a range, or both.

The syntax for specifying a list of individual characters is as follows:

[character_group]

where character_group is a list of the individual characters that can appear in the input string for a match to succeed. character_group can consist of any combination of one or more literal characters, escape characters, or character classes.

The syntax for specifying a range of characters is as follows:

[firstCharacter-lastCharacter]  

where firstCharacter is the character that begins the range and lastCharacter is the character that ends the range. A character range is a contiguous series of characters defined by specifying the first character in the series, a hyphen (-), and then the last character in the series. Two characters are contiguous if they have adjacent Unicode code points.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_positive_character_group_short">
        <source>positive character group</source>
        <target state="new">positive character group</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_start_of_string_only_long">
        <source>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</source>
        <target state="new">The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_start_of_string_only_short">
        <source>start of string only</source>
        <target state="new">start of string only</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_start_of_string_or_line_long">
        <source>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</source>
        <target state="new">The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_start_of_string_or_line_short">
        <source>start of string or line</source>
        <target state="new">start of string or line</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_subexpression">
        <source>subexpression</source>
        <target state="new">subexpression</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_tab_character_long">
        <source>Matches a tab character, \u0009</source>
        <target state="new">Matches a tab character, \u0009</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_tab_character_short">
        <source>tab character</source>
        <target state="new">tab character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_unicode_category_long">
        <source>The Unicode standard assigns each character a general category. For example, a particular character can be an uppercase letter (represented by the Lu category), a decimal digit (the Nd category), a math symbol (the Sm category), or a paragraph separator (the Zl category). Specific character sets in the Unicode standard also occupy a specific range or block of consecutive code points. For example, the basic Latin character set is found from \u0000 through \u007F, while the Arabic character set is found from \u0600 through \u06FF.

The regular expression construct

\p{ name }

matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="new">The Unicode standard assigns each character a general category. For example, a particular character can be an uppercase letter (represented by the Lu category), a decimal digit (the Nd category), a math symbol (the Sm category), or a paragraph separator (the Zl category). Specific character sets in the Unicode standard also occupy a specific range or block of consecutive code points. For example, the basic Latin character set is found from \u0000 through \u007F, while the Arabic character set is found from \u0600 through \u06FF.

The regular expression construct

\p{ name }

matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_unicode_category_short">
        <source>unicode category</source>
        <target state="new">unicode category</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_unicode_escape_long">
        <source>Matches a UTF-16 code unit whose value is #### hexadecimal.</source>
        <target state="new">Matches a UTF-16 code unit whose value is #### hexadecimal.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_unicode_escape_short">
        <source>unicode escape</source>
        <target state="new">unicode escape</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_vertical_tab_character_long">
        <source>Matches a vertical-tab character, \u000B</source>
        <target state="new">Matches a vertical-tab character, \u000B</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_vertical_tab_character_short">
        <source>vertical-tab character</source>
        <target state="new">vertical-tab character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_white_space_character_long">
        <source>\s matches any white-space character. It is equivalent to the escape sequences and Unicode categories listed in the following table.

\f 	The form feed character, \u000C.
\n 	The newline character, \u000A.
\r 	The carriage return character, \u000D.
\t 	The tab character, \u0009.
\v 	The vertical tab character, \u000B.
\x85 	The ellipsis or NEXT LINE (NEL) character (…), \u0085.
\p{Z} 	Matches any separator character.

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</source>
        <target state="new">\s matches any white-space character. It is equivalent to the escape sequences and Unicode categories listed in the following table.

\f 	The form feed character, \u000C.
\n 	The newline character, \u000A.
\r 	The carriage return character, \u000D.
\t 	The tab character, \u0009.
\v 	The vertical tab character, \u000B.
\x85 	The ellipsis or NEXT LINE (NEL) character (…), \u0085.
\p{Z} 	Matches any separator character.

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_white_space_character_short">
        <source>white-space character</source>
        <target state="new">white-space character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_word_boundary_long">
        <source>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        <target state="new">The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_word_boundary_short">
        <source>word boundary</source>
        <target state="new">word boundary</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_word_character_long">
        <source>\w matches any word character. A word character is a member of any of the Unicode categories listed in the following table.

Ll 	Letter, Lowercase
Lu 	Letter, Uppercase
Lt 	Letter, Titlecase
Lo 	Letter, Other
Lm 	Letter, Modifier
Mn 	Mark, Nonspacing
Nd 	Number, Decimal Digit
Pc 	Punctuation, Connector. This category includes ten characters, the most commonly used of which is the LOWLINE character (_), u+005F.

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</source>
        <target state="new">\w matches any word character. A word character is a member of any of the Unicode categories listed in the following table.

Ll 	Letter, Lowercase
Lu 	Letter, Uppercase
Lt 	Letter, Titlecase
Lo 	Letter, Other
Lm 	Letter, Modifier
Mn 	Mark, Nonspacing
Nd 	Number, Decimal Digit
Pc 	Punctuation, Connector. This category includes ten characters, the most commonly used of which is the LOWLINE character (_), u+005F.

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_word_character_short">
        <source>word character</source>
        <target state="new">word character</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_zero_width_negative_lookahead_assertion_long">
        <source>The following grouping construct defines a zero-width negative lookahead assertion:

(?! subexpression )

where subexpression is any regular expression pattern. For the match to be successful, the input string must not match the regular expression pattern in subexpression, although the matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
        <target state="new">The following grouping construct defines a zero-width negative lookahead assertion:

(?! subexpression )

where subexpression is any regular expression pattern. For the match to be successful, the input string must not match the regular expression pattern in subexpression, although the matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_zero_width_negative_lookahead_assertion_short">
        <source>zero-width negative lookahead assertion</source>
        <target state="new">zero-width negative lookahead assertion</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_zero_width_positive_lookahead_assertion_long">
        <source>The following grouping construct defines a zero-width positive lookahead assertion:

(?= subexpression )

where subexpression is any regular expression pattern. For a match to be successful, the input string must match the regular expression pattern in subexpression, although the matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group. For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</source>
        <target state="new">The following grouping construct defines a zero-width positive lookahead assertion:

(?= subexpression )

where subexpression is any regular expression pattern. For a match to be successful, the input string must match the regular expression pattern in subexpression, although the matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group. For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_zero_width_positive_lookahead_assertion_short">
        <source>zero-width positive lookahead assertion</source>
        <target state="new">zero-width positive lookahead assertion</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_zero_width_positive_lookbehind_assertion_long">
        <source>The following grouping construct defines a zero-width positive lookbehind assertion:

(?&lt;= subexpression )

where subexpression is any regular expression pattern. For a match to be successful, subexpression must occur at the input string to the left of the current position, although subexpression is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
        <target state="new">The following grouping construct defines a zero-width positive lookbehind assertion:

(?&lt;= subexpression )

where subexpression is any regular expression pattern. For a match to be successful, subexpression must occur at the input string to the left of the current position, although subexpression is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</target>
        <note />
      </trans-unit>
      <trans-unit id="regex_zero_width_positive_lookbehind_assertion_short">
        <source>zero-width positive lookbehind assertion</source>
        <target state="new">zero-width positive lookbehind assertion</target>
        <note />
      </trans-unit>
      <trans-unit id="x_y_range_in_reverse_order">
        <source>[x-y] range in reverse order</source>
        <target state="new">[x-y] range in reverse order</target>
        <note />
      </trans-unit>
      <trans-unit id="Variables_captured_colon">
        <source>Variables captured:</source>
        <target state="translated">已擷取的變數:</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_issue_0">
        <source>Regex issue: {0}</source>
        <target state="new">Regex issue: {0}</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>