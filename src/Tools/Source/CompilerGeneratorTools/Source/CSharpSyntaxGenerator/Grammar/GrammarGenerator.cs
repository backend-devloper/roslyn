// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis.CSharp;

namespace CSharpSyntaxGenerator.Grammar
{
    internal static class GrammarGenerator
    {
        public static string Run(Tree tree)
        {
            // Syntax refers to a special pseudo-element 'Modifier'.  Synthesize that for the grammar.
            var modifierKeywords = GetMembers<DeclarationModifiers>()
                .SelectMany(m => GetMembers<SyntaxKind>().Where(k => k.ToString() == m + "Keyword"))
                .Select(k => new Kind { Name = k.ToString() });

            tree.Types.Add(new Node
            {
                Name = "Modifier",
                Children = { new Field { Type = "SyntaxToken", Kinds = modifierKeywords.ToList() } }
            });

            var nameToProductions = tree.Types.ToDictionary(n => n.Name, _ => new List<Production>());

            foreach (var node in tree.Types)
            {
                // If this node has a base-type, then have the base-type point to this node as a
                // valid production for itself.
                if (node.Base is string nodeBase && nodeBase != "CSharpSyntaxNode" && nameToProductions.TryGetValue(nodeBase, out var baseProductions))
                    baseProductions.Add(RuleReference(node.Name));

                if (node is Node && node.Children.Count > 0)
                {
                    // Convert a rule of `a: (x | y | z)` into:
                    // a: x
                    //  | y
                    //  | z;
                    var productions = nameToProductions[node.Name];
                    if (node.Children.Count == 1 && node.Children[0] is Field field && field.IsToken)
                    {
                        productions.AddRange(field.Kinds.Select(k =>
                            HandleChildren(new[] { new Field { Type = "SyntaxToken", Kinds = { k } } })));
                        continue;
                    }

                    productions.Add(HandleChildren(node.Children.ToArray()));
                }
            }

            // The grammar will bottom out with certain lexical productions. Create rules for these.
            var lexicalRules = nameToProductions.Values.SelectMany(ps => ps.SelectMany(p => p.ReferencedRules))
                                                       .Where(r => !nameToProductions.ContainsKey(r)).Distinct().ToArray();
            foreach (var name in lexicalRules)
                nameToProductions.Add(name, new List<Production> { new Production("/* see lexical specification */") });

            var seen = new HashSet<string>();

            // Define a few major sections that generally correspond to base nodes that have a lot
            // of derived nodes. If we hit these nodes while recursing through another node, we
            // won't just print them out then. Instead, we'll wait till we're done with the previous
            // nodes, then start emitting these. This helps keep the grammar file naturally grouped.
            var majorRules = ImmutableArray.Create(
                "CompilationUnitSyntax", "MemberDeclarationSyntax", "StatementSyntax", "ExpressionSyntax", "TypeSyntax", "XmlNodeSyntax", "StructuredTriviaSyntax");

            var result = "// <auto-generated />" + Environment.NewLine + "grammar csharp;" + Environment.NewLine;

            // Handle each major section first and then walk any missed rules.
            foreach (var rule in majorRules.Concat(nameToProductions.Keys.OrderBy(a => a)))
                processRule(rule, ref result);

            return result;

            void processRule(string name, ref string result)
            {
                // Only consider the rule if it's the first time we're seeing it.
                if (seen.Add(name))
                {
                    // Order the productions to keep us independent from whatever changes happen in Syntax.xml.
                    var sorted = nameToProductions[name].OrderBy(v => v);
                    if (sorted.Any())
                    {
                        result += Environment.NewLine + RuleReference(name).Text + Environment.NewLine + "  : " +
                                  string.Join(Environment.NewLine + "  | ", sorted) + Environment.NewLine + "  ;" + Environment.NewLine;

                        // Now proceed in depth-first fashion through the rules the productions of this rule
                        // reference.  This helps keep related rules of these productions close by.
                        var references = sorted.SelectMany(t => t.ReferencedRules);
                        foreach (var referencedRule in references.Where(r => !majorRules.Concat(lexicalRules).Contains(r)))
                            processRule(referencedRule, ref result);
                    }
                }
            }
        }

        private static Production Join(string delim, IEnumerable<Production> productions)
            => new Production(string.Join(delim, productions.Where(p => p.Text.Length > 0)), productions.SelectMany(p => p.ReferencedRules));

        private static Production HandleChildren(TreeTypeChild[] children, string delim = " ")
            => Join(delim, children.Select(child =>
                child is Choice c ? HandleChildren(c.Children.ToArray(), delim: " | ").Parenthesize() :
                child is Sequence s ? HandleChildren(s.Children.ToArray()).Parenthesize() :
                child is Field f ? HandleField(f).Suffix("?", when: f.IsOptional) : throw new InvalidOperationException()));

        private static Production HandleField(Field field)
            // 'bool' fields are for a few properties we generate on DirectiveTrivia. They're not
            // relevant to the grammar, so we just return an empty production to ignore them.
            => field.Type == "bool" ? new Production("") :
               field.Type == "CSharpSyntaxNode" ? RuleReference(field.Kinds.Single().Name + "Syntax") :
               field.Type.StartsWith("SeparatedSyntaxList") ? HandleSeparatedList(field, field.Type[("SeparatedSyntaxList".Length + 1)..^1]) :
               field.Type.StartsWith("SyntaxList") ? HandleList(field, field.Type[("SyntaxList".Length + 1)..^1]) :
               field.IsToken ? HandleTokenField(field) : RuleReference(field.Type);

        private static Production HandleSeparatedList(Field field, string elementType)
            => RuleReference(elementType).Suffix(" (',' " + RuleReference(elementType) + ")*")
                .Suffix(" ','?", when: field.AllowTrailingSeparator)
                .Parenthesize(when: field.MinCount == 0).Suffix("?", when: field.MinCount == 0);

        private static Production HandleList(Field field, string elementType)
            => (elementType != "SyntaxToken" ? RuleReference(elementType) :
                field.Name == "Commas" ? new Production("','") :
                field.Name == "Modifiers" ? RuleReference("Modifier") :
                field.Name == "TextTokens" ? RuleReference(nameof(SyntaxKind.XmlTextLiteralToken)) : RuleReference("Token"))
                    .Suffix(field.MinCount == 0 ? "*" : "+");

        private static Production HandleTokenField(Field field)
            => field.Kinds.Count == 0 ? GetTokenProduction(field.Name) : Join(" | ", field.Kinds.Select(
                k => GetTokenProduction(k.Name)).OrderBy(p => p)).Parenthesize(when: field.Kinds.Count >= 2);

        private static Production GetTokenProduction(string tokenName)
        {
            var kind = GetMembers<SyntaxKind>().Where(k => k.ToString() == tokenName).SingleOrDefault();
            return kind switch
            {
                SyntaxKind.EndOfFileToken => new Production("EOF"), // 'EOF' is builtin to antlr to represent this concept.
                SyntaxKind.EndOfDocumentationCommentToken => new Production(""),
                SyntaxKind.EndOfDirectiveToken => new Production(""),
                SyntaxKind.OmittedTypeArgumentToken => new Production("/* epsilon */"),
                SyntaxKind.OmittedArraySizeExpressionToken => new Production("/* epsilon */"),
                SyntaxKind.None => RuleReference("Token"),
                _ => SyntaxFacts.GetText(kind) is var text && text != ""
                    ? new Production(text == "'" ? "'\\''" : $"'{text}'")
                    : RuleReference(kind.ToString()),
            };
        }

        private static IEnumerable<TEnum> GetMembers<TEnum>() where TEnum : struct, Enum
            => typeof(TEnum).GetFields(BindingFlags.Public | BindingFlags.Static).Select(f => f.GetValue(null)).OfType<TEnum>();

        private static Production RuleReference(string name)
            => new Production(
                s_normalizationRegex.Replace(name.EndsWith("Syntax") ? name[..^"Syntax".Length] : name, "_").ToLower(),
                ImmutableArray.Create(name));

        // Converts a PascalCased name into snake_cased name.
        private static readonly Regex s_normalizationRegex = new Regex(
            "(?<=[A-Z])(?=[A-Z][a-z]) | (?<=[^A-Z])(?=[A-Z]) | (?<=[A-Za-z])(?=[^A-Za-z])",
            RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled);
    }

    internal struct Production : IComparable<Production>
    {
        public readonly string Text;
        public readonly ImmutableArray<string> ReferencedRules;

        public Production(string text, IEnumerable<string> referencedRules = null)
        {
            Text = text;
            ReferencedRules = referencedRules == null ? ImmutableArray<string>.Empty : referencedRules.ToImmutableArray();
        }

        public override string ToString() => Text;
        public int CompareTo(Production other) => StringComparer.Ordinal.Compare(this.Text, other.Text);
        public Production Prefix(string prefix) => new Production(prefix + this, ReferencedRules);
        public Production Suffix(string suffix, bool when = true) => when ? new Production(this + suffix, ReferencedRules) : this;
        public Production Parenthesize(bool when = true) => when ? Prefix("(").Suffix(")") : this;
    }
}

namespace Microsoft.CodeAnalysis
{
    internal static class GreenNode
    {
        internal const int ListKind = 1; // See SyntaxKind.
    }
}
