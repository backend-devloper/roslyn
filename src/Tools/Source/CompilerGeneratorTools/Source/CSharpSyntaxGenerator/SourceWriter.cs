// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;

namespace CSharpSyntaxGenerator
{
    internal class SourceWriter : AbstractFileWriter
    {
        private SourceWriter(TextWriter writer, Tree tree)
            : base(writer, tree)
        {
        }

        public static void WriteMain(TextWriter writer, Tree tree) => new SourceWriter(writer, tree).WriteMain();

        public static void WriteInternal(TextWriter writer, Tree tree) => new SourceWriter(writer, tree).WriteInternal();

        public static void WriteSyntax(TextWriter writer, Tree tree) => new SourceWriter(writer, tree).WriteSyntax();

        private void WriteFileHeader()
        {
            WriteLine("// <auto-generated />");
            WriteLine();
            WriteLine("#nullable enable");
            WriteLine();
            WriteLine("using System;");
            WriteLine("using System.Collections.Generic;");
            WriteLine("using Microsoft.CodeAnalysis.Syntax.InternalSyntax;");
            WriteLine("using Roslyn.Utilities;");
            WriteLine();
        }

        private void WriteInternal()
        {
            WriteFileHeader();

            WriteLine("namespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax");
            OpenBlock();
            WriteLine();
            this.WriteGreenTypes();
            this.WriteGreenVisitors();
            this.WriteGreenRewriter();
            this.WriteContextualGreenFactories();
            this.WriteStaticGreenFactories();
            CloseBlock();
        }

        private void WriteSyntax()
        {
            WriteFileHeader();
            WriteLine("namespace Microsoft.CodeAnalysis.CSharp.Syntax");
            OpenBlock();
            WriteLine();
            this.WriteRedTypes();
            CloseBlock();
        }

        private void WriteMain()
        {
            WriteFileHeader();
            WriteLine("namespace Microsoft.CodeAnalysis.CSharp");
            OpenBlock();
            WriteLine("using Microsoft.CodeAnalysis.CSharp.Syntax;");
            this.WriteRedVisitors();
            this.WriteRedRewriter();
            this.WriteRedFactories();
            CloseBlock();
        }

        private void WriteGreenTypes()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();
            foreach (var node in nodes)
            {
                WriteLine();
                this.WriteGreenType(node);
            }
        }

        private void WriteGreenType(TreeType node)
        {
            WriteComment(node.TypeComment, "");

            if (node is AbstractNode)
            {
                var nd = (AbstractNode)node;
                WriteLine(string.Format("internal abstract partial class {0} : {1}", node.Name, node.Base));
                OpenBlock();

                // ctor with diagnostics and annotations
                WriteLine(string.Format("internal {0}(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)", node.Name));
                WriteLine("  : base(kind, diagnostics, annotations)");
                OpenBlock();
                if (node.Name == "DirectiveTriviaSyntax")
                {
                    WriteLine("this.flags |= NodeFlags.ContainsDirectives;");
                }
                CloseBlock();
                WriteLine();
                // ctor without diagnostics and annotations
                WriteLine(string.Format("internal {0}(SyntaxKind kind)", node.Name));
                WriteLine("  : base(kind)");
                OpenBlock();
                if (node.Name == "DirectiveTriviaSyntax")
                {
                    WriteLine("this.flags |= NodeFlags.ContainsDirectives;");
                }
                CloseBlock();

                // object reader constructor
                WriteLine();
                WriteLine(string.Format("protected {0}(ObjectReader reader)", node.Name));
                WriteLine("  : base(reader)");
                OpenBlock();
                if (node.Name == "DirectiveTriviaSyntax")
                {
                    WriteLine("this.flags |= NodeFlags.ContainsDirectives;");
                }
                CloseBlock();

                var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
                var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

                foreach (var field in nodeFields)
                {
                    if (IsNodeOrNodeList(field.Type))
                    {
                        WriteLine();
                        WriteComment(field.PropertyComment, "");

                        if (IsSeparatedNodeList(field.Type) ||
                            IsNodeList(field.Type))
                        {
                            WriteLine(string.Format("public abstract {0}Microsoft.CodeAnalysis.Syntax.InternalSyntax.{1} {2} {{ get; }}", (IsNew(field) ? "new " : ""), field.Type, field.Name));
                        }
                        else
                        {
                            WriteLine(string.Format("public abstract {0}{1} {2} {{ get; }}", (IsNew(field) ? "new " : ""), GetFieldType(field, green: true), field.Name));
                        }
                    }
                }

                foreach (var field in valueFields)
                {
                    WriteLine();
                    WriteComment(field.PropertyComment, "");

                    WriteLine(string.Format("public abstract {0}{1} {2} {{ get; }}", (IsNew(field) ? "new " : ""), field.Type, field.Name));
                }

                CloseBlock();
            }
            else if (node is Node)
            {
                var nd = (Node)node;

                WriteLine(string.Format("internal sealed partial class {0} : {1}", node.Name, node.Base));
                OpenBlock();

                var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
                var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

                foreach (var field in nodeFields)
                {
                    var type = GetFieldType(field, green: true);
                    WriteLine(string.Format("internal readonly {0} {1};", type, CamelCase(field.Name)));
                }

                foreach (var field in valueFields)
                {
                    WriteLine(string.Format("internal readonly {0} {1};", field.Type, CamelCase(field.Name)));
                }

                // write constructor with diagnostics and annotations
                WriteLine();
                Write(string.Format("internal {0}(SyntaxKind kind", node.Name));

                WriteGreenNodeConstructorArgs(nodeFields, valueFields);

                WriteLine(", DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)");
                WriteLine("  : base(kind, diagnostics, annotations)");
                OpenBlock();
                WriteCtorBody(valueFields, nodeFields);
                CloseBlock();

                // write constructor with async
                WriteLine();
                Write(string.Format("internal {0}(SyntaxKind kind", node.Name));

                WriteGreenNodeConstructorArgs(nodeFields, valueFields);

                WriteLine(", SyntaxFactoryContext context)");
                WriteLine("  : base(kind)");
                OpenBlock();
                WriteLine("this.SetFactoryContext(context);");
                WriteCtorBody(valueFields, nodeFields);
                CloseBlock();

                // write constructor without diagnostics and annotations
                WriteLine();
                Write(string.Format("internal {0}(SyntaxKind kind", node.Name));

                WriteGreenNodeConstructorArgs(nodeFields, valueFields);

                WriteLine(")");
                WriteLine("  : base(kind)");
                OpenBlock();
                WriteCtorBody(valueFields, nodeFields);
                CloseBlock();
                WriteLine();

                // property accessors
                foreach (var field in nodeFields)
                {
                    WriteComment(field.PropertyComment, "");
                    if (IsNodeList(field.Type))
                    {
                        WriteLine(string.Format("public {0}Microsoft.CodeAnalysis.Syntax.InternalSyntax.{1} {2} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.{1}(this.{3});", OverrideOrNewModifier(field), field.Type, field.Name, CamelCase(field.Name)));
                    }
                    else if (IsSeparatedNodeList(field.Type))
                    {
                        WriteLine(string.Format("public {0}Microsoft.CodeAnalysis.Syntax.InternalSyntax.{1} {2} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.{1}(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.{3}));", OverrideOrNewModifier(field), field.Type, field.Name, CamelCase(field.Name)));
                    }
                    else if (field.Type == "SyntaxNodeOrTokenList")
                    {
                        WriteLine(string.Format("public {0}Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode> {1} => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.{2});", OverrideOrNewModifier(field), field.Name, CamelCase(field.Name)));
                    }
                    else
                    {
                        WriteLine(string.Format("public {0}{1} {2} => this.{3};", OverrideOrNewModifier(field), GetFieldType(field, green: true), field.Name, CamelCase(field.Name)));
                    }
                }

                foreach (var field in valueFields)
                {
                    WriteComment(field.PropertyComment, "");
                    WriteLine(string.Format("public {0}{1} {2} => this.{3};", OverrideOrNewModifier(field), field.Type, field.Name, CamelCase(field.Name)));
                }

                // GetSlot
                WriteLine();
                Write("internal override GreenNode? GetSlot(int index)");

                if (nodeFields.Count == 0)
                {
                    WriteLine(" => null;");
                }
                else if (nodeFields.Count == 1)
                {
                    WriteLine();
                    Indent();
                    WriteLine(string.Format("=> index == 0 ? this.{0} : null;", CamelCase(nodeFields[0].Name)));
                    Unindent();
                }
                else
                {
                    WriteLine();
                    Indent();
                    WriteLine("=> index switch");
                    OpenBlock();
                    for (int i = 0, n = nodeFields.Count; i < n; i++)
                    {
                        var field = nodeFields[i];
                        WriteLine(string.Format("{0} => this.{1},", i, CamelCase(field.Name)));
                    }
                    WriteLine("_ => null,");
                    CloseBlock(";");
                    Unindent();
                }

                WriteLine();
                WriteLine(string.Format("internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.{0}(this, parent, position);", node.Name));

                this.WriteGreenAcceptMethods(nd);
                this.WriteGreenUpdateMethod(nd);
                this.WriteSetDiagnostics(nd);
                this.WriteSetAnnotations(nd);

                this.WriteGreenSerialization(nd);
                CloseBlock();
            }
        }

        private void WriteGreenNodeConstructorArgs(List<Field> nodeFields, List<Field> valueFields)
        {
            foreach (var field in nodeFields)
            {
                Write(string.Format(", {0} {1}", GetFieldType(field, green: true), CamelCase(field.Name)));
            }

            foreach (var field in valueFields)
            {
                Write(string.Format(", {0} {1}", field.Type, CamelCase(field.Name)));
            }
        }

        private void WriteGreenSerialization(Node node)
        {
            var valueFields = node.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
            var nodeFields = node.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

            // object reader constructor
            WriteLine();
            WriteLine(string.Format("internal {0}(ObjectReader reader)", node.Name));
            WriteLine("  : base(reader)");
            OpenBlock();
            WriteLine(string.Format("this.SlotCount = {0};", nodeFields.Count));

            foreach (var field in nodeFields)
            {
                string type = GetFieldType(field, green: true);
                WriteLine(string.Format("var {0} = ({1})reader.ReadValue();", CamelCase(field.Name), type));

                if (IsAnyList(field.Type) || IsOptional(field))
                {
                    WriteLine(string.Format("if ({0} != null)", CamelCase(field.Name)));
                    OpenBlock();
                    WriteLine(string.Format("AdjustFlagsAndWidth({0});", CamelCase(field.Name)));
                    WriteLine(string.Format("this.{0} = {0};", CamelCase(field.Name), type));
                    CloseBlock();
                }
                else
                {
                    WriteLine(string.Format("AdjustFlagsAndWidth({0});", CamelCase(field.Name)));
                    WriteLine(string.Format("this.{0} = {0};", CamelCase(field.Name), type));
                }
            }

            foreach (var field in valueFields)
            {
                WriteLine(string.Format("this.{0} = ({1})reader.{2}();", CamelCase(field.Name), GetFieldType(field, green: true), GetReaderMethod(GetFieldType(field, green: true))));
            }

            CloseBlock();

            // IWritable
            WriteLine();
            WriteLine("internal override void WriteTo(ObjectWriter writer)");
            OpenBlock();
            WriteLine("base.WriteTo(writer);");

            foreach (var field in nodeFields)
            {
                WriteLine(string.Format("writer.WriteValue(this.{0});", CamelCase(field.Name)));
            }

            foreach (var field in valueFields)
            {
                var type = GetFieldType(field, green: true);
                WriteLine(string.Format("writer.{0}(this.{1});", GetWriterMethod(type), CamelCase(field.Name)));
            }

            CloseBlock();

            // IReadable
            WriteLine();
            WriteLine(string.Format("static {0}()", node.Name));
            OpenBlock();
            WriteLine(string.Format("ObjectBinder.RegisterTypeReader(typeof({0}), r => new {0}(r));", node.Name));
            CloseBlock();
        }

        private string GetWriterMethod(string type)
        {
            switch (type)
            {
                case "bool":
                    return "WriteBoolean";
                default:
                    throw new InvalidOperationException($"Type '{type}' not supported for object reader serialization.");
            }
        }

        private string GetReaderMethod(string type)
        {
            switch (type)
            {
                case "bool":
                    return "ReadBoolean";
                default:
                    throw new InvalidOperationException($"Type '{type}' not supported for object reader serialization.");
            }
        }

        private void WriteCtorBody(List<Field> valueFields, List<Field> nodeFields)
        {
            // constructor body
            WriteLine(string.Format("this.SlotCount = {0};", nodeFields.Count));

            foreach (var field in nodeFields)
            {
                if (IsAnyList(field.Type) || IsOptional(field))
                {
                    WriteLine(string.Format("if ({0} != null)", CamelCase(field.Name)));
                    OpenBlock();
                    WriteLine(string.Format("this.AdjustFlagsAndWidth({0});", CamelCase(field.Name)));
                    WriteLine(string.Format("this.{0} = {0};", CamelCase(field.Name)));
                    CloseBlock();
                }
                else
                {
                    WriteLine(string.Format("this.AdjustFlagsAndWidth({0});", CamelCase(field.Name)));
                    WriteLine(string.Format("this.{0} = {0};", CamelCase(field.Name)));
                }
            }

            foreach (var field in valueFields)
            {
                WriteLine(string.Format("this.{0} = {0};", CamelCase(field.Name)));
            }
        }

        private void WriteSetAnnotations(Node node)
        {
            WriteLine();
            WriteLine("internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)");
            Write(string.Format("    => new {0}(this.Kind, ", node.Name));
            foreach (var field in node.Fields)
            {
                if (field != node.Fields.First())
                    Write(", ");
                Write(string.Format("this.{0}", CamelCase(field.Name)));
            }
            WriteLine(", GetDiagnostics(), annotations);");
        }

        private void WriteSetDiagnostics(Node node)
        {
            WriteLine();
            WriteLine("internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)");
            Write(string.Format("    => new {0}(this.Kind, ", node.Name));
            foreach (var field in node.Fields)
            {
                if (field != node.Fields.First())
                    Write(", ");
                Write(string.Format("this.{0}", CamelCase(field.Name)));
            }
            WriteLine(", diagnostics, GetAnnotations());");
        }

        private void WriteGreenAcceptMethods(Node node)
        {
            WriteLine();
            WriteLine(string.Format("public override void Accept(CSharpSyntaxVisitor visitor) => visitor.Visit{0}(this);", StripPost(node.Name, "Syntax")));
            WriteLine(string.Format("public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.Visit{0}(this);", StripPost(node.Name, "Syntax")));
        }

        private void WriteGreenVisitors()
        {
            WriteGreenVisitor(withResult: true);
            WriteGreenVisitor(withResult: false);
        }

        private void WriteGreenVisitor(bool withResult)
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();

            WriteLine();
            WriteLine("internal partial class CSharpSyntaxVisitor" + (withResult ? "<TResult>" : ""));
            OpenBlock();
            foreach (var node in nodes.OfType<Node>())
            {
                WriteLine(string.Format("public virtual {0} Visit{1}({2} node) => this.DefaultVisit(node);", withResult ? "TResult" : "void", StripPost(node.Name, "Syntax"), node.Name));
            }
            CloseBlock();
        }

        private void WriteGreenUpdateMethod(Node node)
        {
            WriteLine();
            Write(string.Format("public {0} Update(", node.Name));

            // parameters
            foreach (var field in node.Fields)
            {
                if (field != node.Fields.First())
                    Write(", ");

                var type =
                    field.Type == "SyntaxNodeOrTokenList" ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>" :
                    field.Type == "SyntaxTokenList" ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>" :
                    IsNodeList(field.Type) ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax." + field.Type :
                    IsSeparatedNodeList(field.Type) ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax." + field.Type :
                    field.Type;

                Write(string.Format("{0} {1}", type, CamelCase(field.Name)));
            }
            WriteLine(")");
            OpenBlock();

            Write("if (");
            int nCompared = 0;
            foreach (var field in node.Fields)
            {
                if (IsDerivedOrListOfDerived("SyntaxNode", field.Type) || IsDerivedOrListOfDerived("SyntaxToken", field.Type) || field.Type == "SyntaxNodeOrTokenList")
                {
                    if (nCompared > 0)
                        Write(" || ");
                    Write(string.Format("{0} != this.{1}", CamelCase(field.Name), field.Name));
                    nCompared++;
                }
            }
            if (nCompared > 0)
            {
                WriteLine(")");
                OpenBlock();
                Write(string.Format("var newNode = SyntaxFactory.{0}(", StripPost(node.Name, "Syntax")));
                if (node.Kinds.Count > 1)
                {
                    Write("this.Kind, ");
                }
                foreach (var field in node.Fields)
                {
                    if (field != node.Fields.First())
                        Write(", ");
                    Write(CamelCase(field.Name));
                }
                WriteLine(");");
                WriteLine("var diags = GetDiagnostics();");
                WriteLine("if (diags?.Length > 0)");
                WriteLine("    newNode = newNode.WithDiagnosticsGreen(diags);");
                WriteLine("var annotations = GetAnnotations();");
                WriteLine("if (annotations?.Length > 0)");
                WriteLine("    newNode = newNode.WithAnnotationsGreen(annotations);");
                WriteLine("return newNode;");
                CloseBlock();
            }

            WriteLine();
            WriteLine("return this;");
            CloseBlock();
        }

        private void WriteGreenRewriter()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();

            WriteLine();
            WriteLine("internal partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<CSharpSyntaxNode>");
            OpenBlock();
            int nWritten = 0;
            foreach (var node in nodes.OfType<Node>())
            {
                var nodeFields = node.Fields.Where(nd => IsNodeOrNodeList(nd.Type)).ToList();

                if (nWritten > 0)
                    WriteLine();
                nWritten++;
                WriteLine(string.Format("public override CSharpSyntaxNode Visit{0}({1} node)", StripPost(node.Name, "Syntax"), node.Name));
                Indent();

                if (nodeFields.Count == 0)
                {
                    WriteLine("=> node;");
                }
                else
                {
                    Write("=> node.Update(");

                    foreach (var field in node.Fields)
                    {
                        if (field != node.Fields.First())
                            Write(", ");

                        if (IsAnyList(field.Type))
                        {
                            Write(string.Format("VisitList(node.{1})", CamelCase(field.Name), field.Name));
                        }
                        else if (IsNode(field.Type))
                        {
                            Write(string.Format("({1})Visit(node.{2})", CamelCase(field.Name), field.Type, field.Name));
                        }
                        else
                        {
                            Write(string.Format("node.{0}", field.Name));
                        }
                    }

                    WriteLine(");");
                }

                Unindent();
            }

            CloseBlock();
        }

        private void WriteContextualGreenFactories()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode) && !(n is AbstractNode)).ToList();
            WriteLine();
            WriteLine("internal partial class ContextAwareSyntax");
            OpenBlock();
            WriteLine();
            WriteLine("private SyntaxFactoryContext context;");

            WriteLine();
            WriteLine("public ContextAwareSyntax(SyntaxFactoryContext context)");
            WriteLine("    => this.context = context;");

            WriteGreenFactories(nodes, withSyntaxFactoryContext: true);
            CloseBlock();
        }

        private void WriteStaticGreenFactories()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode) && !(n is AbstractNode)).ToList();
            WriteLine();
            WriteLine("internal static partial class SyntaxFactory");
            OpenBlock();
            WriteGreenFactories(nodes);
            WriteGreenTypeList();
            CloseBlock();
        }

        private void WriteGreenFactories(List<TreeType> nodes, bool withSyntaxFactoryContext = false)
        {
            foreach (var node in nodes.OfType<Node>())
            {
                WriteLine();
                this.WriteGreenFactory(node, withSyntaxFactoryContext);
            }
        }

        private void WriteGreenTypeList()
        {
            WriteLine();
            WriteLine("internal static IEnumerable<Type> GetNodeTypes()");
            Indent();
            WriteLine("=> new Type[]");
            OpenBlock();

            var nodes = Tree.Types.Where(n => !(n is PredefinedNode) && !(n is AbstractNode)).ToList();
            foreach (var node in nodes)
            {
                WriteLine(string.Format("typeof({0}),", node.Name));
            }

            CloseBlock(";");
            Unindent();
        }

        private void WriteGreenFactory(Node nd, bool withSyntaxFactoryContext = false)
        {
            var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
            var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

            Write(string.Format("public {0}{1} {2}(", withSyntaxFactoryContext ? "" : "static ", nd.Name, StripPost(nd.Name, "Syntax")));
            WriteGreenFactoryParameters(nd);
            WriteLine(")");
            OpenBlock();

            // validate kind
            if (nd.Kinds.Count >= 2)
            {
                WriteLine("switch (kind)");
                OpenBlock();
                foreach (var kind in nd.Kinds)
                {
                    WriteLine(string.Format("case SyntaxKind.{0}:{1}", kind.Name, kind == nd.Kinds.Last() ? " break;" : ""));
                }
                WriteLine("default: throw new ArgumentException(nameof(kind));");
                CloseBlock();
            }

            // validate parameters
            WriteLine("#if DEBUG");
            foreach (var field in nodeFields)
            {
                var pname = CamelCase(field.Name);

                if (!IsAnyList(field.Type) && !IsOptional(field))
                {
                    WriteLine(string.Format("if ({0} == null) throw new ArgumentNullException(nameof({0}));", CamelCase(field.Name)));
                }
                if (field.Type == "SyntaxToken" && field.Kinds != null && field.Kinds.Count > 0)
                {
                    if (IsOptional(field))
                    {
                        WriteLine(string.Format("if ({0} != null)", CamelCase(field.Name)));
                        OpenBlock();
                    }

                    if (field.Kinds.Count == 1 && !IsOptional(field))
                    {
                        WriteLine(string.Format("if ({0}.Kind != SyntaxKind.{1}) throw new ArgumentException(nameof({0}));", pname, field.Kinds[0].Name));
                    }
                    else
                    {
                        WriteLine(string.Format("switch ({0}.Kind)", pname));
                        OpenBlock();
                        var kinds = field.Kinds.ToList();

                        //we need to check for Kind=None as well as node == null because that's what the red factory will pass
                        if (IsOptional(field))
                        {
                            kinds.Add(new Kind { Name = "None" });
                        }
                        foreach (var kind in kinds)
                        {
                            WriteLine(string.Format("case SyntaxKind.{0}:{1}", kind.Name, kind == kinds.Last() ? " break;" : ""));
                        }

                        WriteLine(string.Format("default: throw new ArgumentException(nameof({0}));", pname));
                        CloseBlock();
                    }

                    if (IsOptional(field))
                    {
                        CloseBlock();
                    }
                }
            }

            WriteLine("#endif");

            if (nd.Name != "SkippedTokensTriviaSyntax" &&
                nd.Name != "DocumentationCommentTriviaSyntax" &&
                nd.Name != "IncompleteMemberSyntax" &&
                valueFields.Count + nodeFields.Count <= 3)
            {
                //int hash;
                //var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
                //if (cached != null) return (IdentifierNameSyntax)cached;

                //var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
                //if (hash >= 0)
                //{
                //    SyntaxNodeCache.AddNode(result, hash);
                //}

                //return result;

                WriteLine();
                //int hash;
                WriteLine("int hash;");
                //SyntaxNode cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IdentifierName, identifier, this.context, out hash);
                if (withSyntaxFactoryContext)
                {
                    Write("var cached = CSharpSyntaxNodeCache.TryGetNode((int)");
                }
                else
                {
                    Write("var cached = SyntaxNodeCache.TryGetNode((int)");
                }

                WriteCtorArgList(nd, withSyntaxFactoryContext, valueFields, nodeFields);
                WriteLine(", out hash);");
                //    if (cached != null) return (IdentifierNameSyntax)cached;
                WriteLine(string.Format("if (cached != null) return ({0})cached;", nd.Name));
                WriteLine();

                //var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
                Write(string.Format("var result = new {0}(", nd.Name));
                WriteCtorArgList(nd, withSyntaxFactoryContext, valueFields, nodeFields);
                WriteLine(");");
                //if (hash >= 0)
                WriteLine("if (hash >= 0)");
                //{
                OpenBlock();
                //    SyntaxNodeCache.AddNode(result, hash);
                WriteLine("SyntaxNodeCache.AddNode(result, hash);");
                //}
                CloseBlock();
                WriteLine();

                //return result;
                WriteLine("return result;");
            }
            else
            {
                WriteLine();
                Write(string.Format("return new {0}(", nd.Name));
                WriteCtorArgList(nd, withSyntaxFactoryContext, valueFields, nodeFields);
                WriteLine(");");
            }

            CloseBlock();
        }

        private void WriteGreenFactoryParameters(Node nd)
        {
            if (nd.Kinds.Count > 1)
            {
                Write("SyntaxKind kind, ");
            }
            foreach (var field in nd.Fields)
            {
                if (field != nd.Fields.First())
                    Write(", ");
                var type = field.Type;
                if (type == "SyntaxNodeOrTokenList")
                {
                    type = "Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>";
                }
                else if (IsSeparatedNodeList(field.Type) ||
                         IsNodeList(field.Type))
                {
                    type = "Microsoft.CodeAnalysis.Syntax.InternalSyntax." + type;
                }
                else
                {
                    type = GetFieldType(field, green: true);
                }

                Write(string.Format("{0} {1}", type, CamelCase(field.Name)));
            }
        }

        private void WriteCtorArgList(Node nd, bool withSyntaxFactoryContext, List<Field> valueFields, List<Field> nodeFields)
        {
            if (nd.Kinds.Count == 1)
            {
                Write("SyntaxKind.");
                Write(nd.Kinds[0].Name);
            }
            else
            {
                Write("kind");
            }
            foreach (var field in nodeFields)
            {
                Write(", ");
                if (field.Type == "SyntaxList<SyntaxToken>" || IsAnyList(field.Type))
                {
                    Write(string.Format("{0}.Node", CamelCase(field.Name)));
                }
                else
                {
                    Write(CamelCase(field.Name));
                }
            }
            // values are at end
            foreach (var field in valueFields)
            {
                Write(", ");
                Write(CamelCase(field.Name));
            }
            if (withSyntaxFactoryContext)
            {
                Write(", this.context");
            }
        }

        private void WriteRedTypes()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();
            foreach (var node in nodes)
            {
                WriteLine();
                this.WriteRedType(node);
            }
        }

        private List<Field> GetNodeOrNodeListFields(TreeType node)
            => node is AbstractNode an
                ? an.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList()
                : node is Node nd
                    ? nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList()
                    : new List<Field>();

        private void WriteRedType(TreeType node)
        {
            WriteComment(node.TypeComment, "");

            if (node is AbstractNode)
            {
                var nd = (AbstractNode)node;
                WriteLine(string.Format("public abstract partial class {0} : {1}", node.Name, node.Base));
                OpenBlock();
                WriteLine(string.Format("internal {0}(InternalSyntax.CSharpSyntaxNode green, SyntaxNode? parent, int position)", node.Name));
                WriteLine("  : base(green, parent, position)");
                OpenBlock();
                CloseBlock();

                var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
                var nodeFields = GetNodeOrNodeListFields(nd);

                foreach (var field in nodeFields)
                {
                    if (IsNodeOrNodeList(field.Type))
                    {
                        //red SyntaxLists can't contain tokens, so we switch to SyntaxTokenList
                        var fieldType = GetRedFieldType(field);
                        WriteLine();
                        WriteComment(field.PropertyComment, "");
                        WriteLine(string.Format("{0} abstract {1}{2} {3} {{ get; }}", "public", (IsNew(field) ? "new " : ""), fieldType, field.Name));
                        WriteLine($"public {node.Name} With{field.Name}({fieldType} {CamelCase(field.Name)}) => With{field.Name}Core({CamelCase(field.Name)});");
                        WriteLine($"internal abstract {node.Name} With{field.Name}Core({fieldType} {CamelCase(field.Name)});");

                        if (IsAnyList(field.Type))
                        {
                            var argType = GetElementType(field.Type);
                            WriteLine();
                            WriteLine(string.Format("public {0} Add{1}(params {2}[] items) => Add{1}Core(items);", node.Name, field.Name, argType));
                            WriteLine(string.Format("internal abstract {0} Add{1}Core(params {2}[] items);", node.Name, field.Name, argType));
                        }
                        else
                        {
                            var referencedNode = TryGetNodeForNestedList(field);
                            if (referencedNode != null)
                            {
                                foreach (var referencedNodeField in referencedNode.Fields)
                                {
                                    if (IsAnyList(referencedNodeField.Type))
                                    {
                                        var argType = GetElementType(referencedNodeField.Type);

                                        WriteLine();
                                        WriteLine(string.Format("public {0} Add{1}{2}(params {3}[] items) => Add{1}{2}Core(items);", node.Name, StripPost(field.Name, "Opt"), referencedNodeField.Name, argType));
                                        WriteLine(string.Format("internal abstract {0} Add{1}{2}Core(params {3}[] items);", node.Name, StripPost(field.Name, "Opt"), referencedNodeField.Name, argType));
                                    }
                                }
                            }
                        }
                    }
                }

                foreach (var field in valueFields)
                {
                    WriteLine();
                    WriteComment(field.PropertyComment, "");
                    WriteLine(string.Format("{0} abstract {1}{2} {3} {{ get; }}", "public", (IsNew(field) ? "new " : ""), field.Type, field.Name));
                }

                var baseType = GetTreeType(node.Base);
                if (baseType != null)
                {
                    var baseNodeFields = GetNodeOrNodeListFields(baseType);
                    if (baseNodeFields.Count > 0)
                    {
                        WriteLine();
                    }

                    foreach (var baseField in baseNodeFields)
                    {
                        WriteLine($"public new {node.Name} With{baseField.Name}({GetRedFieldType(baseField)} {CamelCase(baseField.Name)}) => ({node.Name})With{baseField.Name}Core({CamelCase(baseField.Name)});");
                    }

                    foreach (var baseField in baseNodeFields)
                    {
                        if (IsAnyList(baseField.Type))
                        {
                            var argType = GetElementType(baseField.Type);
                            WriteLine();
                            WriteLine(string.Format("public new {0} Add{1}(params {2}[] items) => ({0})Add{1}Core(items);", node.Name, baseField.Name, argType));
                        }
                        else
                        {
                            var referencedNode = TryGetNodeForNestedList(baseField);
                            if (referencedNode != null)
                            {
                                // look for list members...
                                foreach (var referencedNodeField in referencedNode.Fields)
                                {
                                    if (IsAnyList(referencedNodeField.Type))
                                    {
                                        var argType = GetElementType(referencedNodeField.Type);

                                        WriteLine();
                                        WriteLine(string.Format("public new {0} Add{1}{2}(params {3}[] items) => Add{1}{2}Core(items);", baseType.Name, StripPost(baseField.Name, "Opt"), referencedNodeField.Name, argType));
                                    }
                                }
                            }
                        }
                    }
                }

                CloseBlock();
            }
            else if (node is Node)
            {
                var nd = (Node)node;
                WriteLine(string.Format("public sealed partial class {0} : {1}", node.Name, node.Base));
                OpenBlock();

                var valueFields = nd.Fields.Where(n => !IsNodeOrNodeList(n.Type)).ToList();
                var nodeFields = nd.Fields.Where(n => IsNodeOrNodeList(n.Type)).ToList();

                foreach (var field in nodeFields)
                {
                    if (field.Type != "SyntaxToken"
                        && field.Type != "SyntaxList<SyntaxToken>")
                    {
                        if (IsSeparatedNodeList(field.Type) || field.Type == "SyntaxNodeOrTokenList")
                        {
                            WriteLine(string.Format("private SyntaxNode? {0};", CamelCase(field.Name)));
                        }
                        else
                        {
                            var type = GetFieldType(field, green: false);
                            WriteLine(string.Format("private {0} {1};", type, CamelCase(field.Name)));
                        }
                    }
                }

                // write constructor
                WriteLine();
                WriteLine(string.Format("internal {0}(InternalSyntax.CSharpSyntaxNode green, SyntaxNode? parent, int position)", node.Name));
                WriteLine("  : base(green, parent, position)");
                OpenBlock();
                CloseBlock();
                WriteLine();

                // property accessors
                for (int i = 0, n = nodeFields.Count; i < n; i++)
                {
                    var field = nodeFields[i];
                    if (field.Type == "SyntaxToken")
                    {
                        WriteComment(field.PropertyComment, "");
                        Write(string.Format("{0} {1}{2} {3}", "public", OverrideOrNewModifier(field), GetRedPropertyType(field), field.Name));
                        if (IsOptional(field))
                        {
                            WriteLine();
                            OpenBlock();
                            WriteLine("get");
                            OpenBlock();
                            WriteLine(string.Format("var slot = ((Syntax.InternalSyntax.{0})this.Green).{1};", node.Name, CamelCase(field.Name)));
                            WriteLine($"return slot != null ? new SyntaxToken(this, slot, {GetChildPosition(i)}, {GetChildIndex(i)}) : default;"); CloseBlock();
                            CloseBlock();
                        }
                        else
                        {
                            WriteLine(string.Format(" => new SyntaxToken(this, ((Syntax.InternalSyntax.{0})this.Green).{1}, {2}, {3});", node.Name, CamelCase(field.Name), GetChildPosition(i), GetChildIndex(i)));
                        }
                    }
                    else if (field.Type == "SyntaxList<SyntaxToken>")
                    {
                        WriteComment(field.PropertyComment, "");
                        WriteLine(string.Format("{0} {1}SyntaxTokenList {2}", "public", OverrideOrNewModifier(field), field.Name));
                        OpenBlock();
                        WriteLine("get");
                        OpenBlock();
                        WriteLine(string.Format("var slot = this.Green.GetSlot({0});", i));
                        WriteLine($"return slot != null ? new SyntaxTokenList(this, slot, {GetChildPosition(i)}, {GetChildIndex(i)}) : default;");
                        CloseBlock();
                        CloseBlock();
                    }
                    else
                    {
                        WriteComment(field.PropertyComment, "");
                        Write(string.Format("{0} {1}{2} {3}", "public", OverrideOrNewModifier(field), GetRedPropertyType(field), field.Name));

                        if (IsNodeList(field.Type))
                        {
                            WriteLine(string.Format(" => new {0}(GetRed(ref this.{1}, {2}));", field.Type, CamelCase(field.Name), i));
                        }
                        else if (IsSeparatedNodeList(field.Type))
                        {
                            WriteLine();
                            OpenBlock();
                            WriteLine("get");
                            OpenBlock();

                            WriteLine(string.Format("var red = GetRed(ref this.{0}, {1});", CamelCase(field.Name), i));
                            WriteLine($"return red != null ? new {field.Type}(red, {GetChildIndex(i)}) : default;");
                            CloseBlock();
                            CloseBlock();
                        }
                        else if (field.Type == "SyntaxNodeOrTokenList")
                        {
                            throw new InvalidOperationException("field cannot be a random SyntaxNodeOrTokenList");
                        }
                        else
                        {
                            var suffix = IsOptional(field) ? "" : "!";
                            if (i == 0)
                            {
                                WriteLine(string.Format(" => GetRedAtZero(ref this.{0}){1};", CamelCase(field.Name), suffix));
                            }
                            else
                            {
                                WriteLine(string.Format(" => GetRed(ref this.{0}, {1}){2};", CamelCase(field.Name), i, suffix));
                            }
                        }
                    }
                    WriteLine();
                }

                foreach (var field in valueFields)
                {
                    WriteComment(field.PropertyComment, "");
                    WriteLine(string.Format("{0} {1}{2} {3} => ((Syntax.InternalSyntax.{4})this.Green).{3};", "public", OverrideOrNewModifier(field), field.Type, field.Name, node.Name));
                    WriteLine();
                }

                {
                    //GetNodeSlot forces creation of a red node.
                    Write("internal override SyntaxNode? GetNodeSlot(int index)");

                    var relevantNodes = nodeFields.Select((field, index) => (field, index))
                                                  .Where(t => t.field.Type != "SyntaxToken" && t.field.Type != "SyntaxList<SyntaxToken>");
                    if (!relevantNodes.Any())
                    {
                        WriteLine(" => null;");
                    }
                    else if (relevantNodes.Count() == 1)
                    {
                        var (field, index) = relevantNodes.Single();
                        var whenTrue = index == 0
                            ? $"GetRedAtZero(ref this.{CamelCase(field.Name)})"
                            : $"GetRed(ref this.{CamelCase(field.Name)}, {index})";

                        var suffix = IsOptional(field) ? "" : "!";
                        WriteLine($" => index == {index} ? {whenTrue}{suffix} : null;");
                    }
                    else
                    {
                        WriteLine();
                        Indent();
                        WriteLine("=> index switch");
                        OpenBlock();
                        foreach (var (field, index) in relevantNodes)
                        {
                            var suffix = IsOptional(field) ? "" : "!";
                            if (index == 0)
                            {
                                WriteLine(string.Format("{0} => GetRedAtZero(ref this.{1}){2},", index, CamelCase(field.Name), suffix));
                            }
                            else
                            {
                                WriteLine(string.Format("{0} => GetRed(ref this.{1}, {0}){2},", index, CamelCase(field.Name), suffix));
                            }
                        }
                        WriteLine("_ => null,");
                        CloseBlock(";");
                        Unindent();
                    }
                }

                WriteLine();

                {
                    //GetCachedSlot returns a red node if we have it.
                    Write("internal override SyntaxNode? GetCachedSlot(int index)");

                    var relevantNodes = nodeFields.Select((field, index) => (field, index))
                                                  .Where(t => t.field.Type != "SyntaxToken" && t.field.Type != "SyntaxList<SyntaxToken>");
                    if (!relevantNodes.Any())
                    {
                        WriteLine(" => null;");
                    }
                    else if (relevantNodes.Count() == 1)
                    {
                        var (field, index) = relevantNodes.Single();
                        WriteLine($" => index == {index} ? this.{CamelCase(field.Name)} : null;");
                    }
                    else
                    {
                        WriteLine();
                        Indent();
                        WriteLine("=> index switch");
                        OpenBlock();
                        foreach (var (field, index) in relevantNodes)
                        {
                            WriteLine($"{index} => this.{CamelCase(field.Name)},");
                        }
                        WriteLine("_ => null,");
                        CloseBlock(";");
                        Unindent();
                    }
                }

                this.WriteRedAcceptMethods(nd);
                this.WriteRedUpdateMethod(nd);
                this.WriteRedWithMethods(nd);
                this.WriteRedListHelperMethods(nd);

                CloseBlock();
            }
        }

        private string GetRedFieldType(Field field)
        {
            if (field.Type == "SyntaxList<SyntaxToken>")
                return "SyntaxTokenList";

            if (IsOptional(field) && IsNode(field.Type) && field.Type != "SyntaxToken")
                return field.Type + "?";

            return field.Type;
        }

        private string GetChildPosition(int i)
            => i == 0 ? "Position" : "GetChildPosition(" + i + ")";

        private string GetChildIndex(int i)
            => i == 0 ? "0" : "GetChildIndex(" + i + ")";

        private void WriteRedAcceptMethods(Node node)
        {
            WriteLine();
            WriteRedAcceptMethod(node, false);
            WriteRedAcceptMethod(node, true);
        }

        private void WriteRedAcceptMethod(Node node, bool genericResult)
        {
            string genericArgs = genericResult ? "<TResult>" : "";
            WriteLine(string.Format("public override " + (genericResult ? "TResult" : "void") + " Accept" + genericArgs + "(CSharpSyntaxVisitor" + genericArgs + " visitor) => visitor.Visit{0}(this);", StripPost(node.Name, "Syntax")));
        }

        private void WriteRedVisitors()
        {
            WriteRedVisitor(genericResult: true);
            WriteRedVisitor(genericResult: false);
        }

        private void WriteRedVisitor(bool genericResult)
        {
            string genericArgs = genericResult ? "<TResult>" : "";
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();

            WriteLine();
            WriteLine("public partial class CSharpSyntaxVisitor" + genericArgs);
            OpenBlock();
            int nWritten = 0;
            foreach (var node in nodes.OfType<Node>())
            {
                if (nWritten > 0)
                    WriteLine();
                nWritten++;
                WriteComment($"<summary>Called when the visitor visits a {node.Name} node.</summary>");
                WriteLine($"public virtual {(genericResult ? "TResult" : "void")} Visit{StripPost(node.Name, "Syntax")}({node.Name} node) => this.DefaultVisit(node);");
            }
            CloseBlock();
        }

        private void WriteRedUpdateMethod(Node node)
        {
            WriteLine();
            Write(string.Format("{0} {1} Update(", "public", node.Name));

            // parameters
            foreach (var field in node.Fields)
            {
                if (field != node.Fields.First())
                    Write(", ");
                Write(string.Format("{0} {1}", GetRedPropertyType(field), CamelCase(field.Name)));
            }
            WriteLine(")");
            OpenBlock();

            Write("if (");
            int nCompared = 0;
            foreach (var field in node.Fields)
            {
                if (IsDerivedOrListOfDerived("SyntaxNode", field.Type) || IsDerivedOrListOfDerived("SyntaxToken", field.Type) || field.Type == "SyntaxNodeOrTokenList")
                {
                    if (nCompared > 0)
                        Write(" || ");
                    Write(string.Format("{0} != this.{1}", CamelCase(field.Name), field.Name));
                    nCompared++;
                }
            }
            if (nCompared > 0)
            {
                WriteLine(")");
                OpenBlock();
                Write(string.Format("var newNode = SyntaxFactory.{0}(", StripPost(node.Name, "Syntax")));
                if (node.Kinds.Count > 1)
                {
                    Write("this.Kind(), ");
                }
                foreach (var field in node.Fields)
                {
                    if (field != node.Fields.First())
                        Write(", ");
                    Write(CamelCase(field.Name));
                }
                WriteLine(");");
                WriteLine("var annotations = GetAnnotations();");
                WriteLine("return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;");
                CloseBlock();
            }

            WriteLine();
            WriteLine("return this;");
            CloseBlock();
        }

        private void WriteRedWithMethods(Node node)
        {
            foreach (var field in node.Fields)
            {
                var type = this.GetRedPropertyType(field);

                if (field == node.Fields.First())
                {
                    WriteLine();
                }

                var isNew = false;
                if (IsOverride(field))
                {
                    var (baseType, baseField) = GetHighestBaseTypeWithField(node, field.Name);
                    if (baseType != null)
                    {
                        Write($"internal override {baseType.Name} With{field.Name}Core({GetRedPropertyType(baseField)} {CamelCase(field.Name)}) => With{field.Name}({CamelCase(field.Name)}");
                        if (IsOptional(baseField) && !IsOptional(field))
                        {
                            Write($" ?? throw new ArgumentNullException(nameof({CamelCase(field.Name)}))");
                        }
                        WriteLine(");");

                        isNew = true;
                    }
                }

                Write(
                    $"public{(isNew ? " new " : " ")}{node.Name} With{StripPost(field.Name, "Opt")}({type} {CamelCase(field.Name)})" +
                    " => Update(");

                // call update inside each setter
                foreach (var field2 in node.Fields)
                {
                    if (field2 != node.Fields.First())
                        Write(", ");

                    if (field2 == field)
                    {
                        this.Write(string.Format("{0}", CamelCase(field2.Name)));
                    }
                    else
                    {
                        this.Write(string.Format("this.{0}", field2.Name));
                    }
                }
                WriteLine(");");
            }
        }

        private (TreeType type, Field field) GetHighestBaseTypeWithField(TreeType node, string name)
        {
            TreeType bestType = null;
            Field bestField = null;
            for (var current = node; current != null; current = TryGetBaseType(current))
            {
                var fields = GetNodeOrNodeListFields(current);
                var field = fields.FirstOrDefault(f => f.Name == name);
                if (field != null)
                {
                    bestType = current;
                    bestField = field;
                }
            }

            return (bestType, bestField);
        }

        private TreeType TryGetBaseType(TreeType node)
            => node is AbstractNode an
                ? GetTreeType(an.Base)
                : node is Node n
                    ? GetTreeType(n.Base)
                    : null;

        private void WriteRedListHelperMethods(Node node)
        {
            var wroteNewLine = false;
            foreach (var field in node.Fields)
            {
                if (IsAnyList(field.Type))
                {
                    if (!wroteNewLine)
                    {
                        WriteLine();
                        wroteNewLine = true;
                    }
                    // write list helper methods for list properties
                    WriteRedListHelperMethods(node, field);
                }
                else
                {
                    var referencedNode = TryGetNodeForNestedList(field);
                    if (referencedNode != null)
                    {
                        // look for list members...
                        foreach (var referencedNodeField in referencedNode.Fields)
                        {
                            if (IsAnyList(referencedNodeField.Type))
                            {
                                if (!wroteNewLine)
                                {
                                    WriteLine();
                                    wroteNewLine = true;
                                }
                                WriteRedNestedListHelperMethods(node, field, referencedNode, referencedNodeField);
                            }
                        }
                    }
                }
            }
        }

        private Node TryGetNodeForNestedList(Field field)
        {
            Node referencedNode = GetNode(field.Type);
            if (referencedNode != null && (!IsOptional(field) || RequiredFactoryArgumentCount(referencedNode) == 0))
            {
                return referencedNode;
            }

            return null;
        }

        private void WriteRedListHelperMethods(Node node, Field field)
        {
            var argType = GetElementType(field.Type);

            var isNew = false;
            if (IsOverride(field))
            {
                var (baseType, baseField) = GetHighestBaseTypeWithField(node, field.Name);
                if (baseType != null)
                {
                    var baseArgType = GetElementType(baseField.Type);
                    WriteLine(string.Format("internal override {0} Add{1}Core(params {2}[] items) => Add{1}(items);", baseType.Name, field.Name, baseArgType));
                    isNew = true;
                }
            }

            WriteLine($"public{(isNew ? " new " : " ")}{node.Name} Add{field.Name}(params {argType}[] items) => With{StripPost(field.Name, "Opt")}(this.{field.Name}.AddRange(items));");
        }

        private void WriteRedNestedListHelperMethods(Node node, Field field, Node referencedNode, Field referencedNodeField)
        {
            var argType = GetElementType(referencedNodeField.Type);

            var isNew = false;
            if (IsOverride(field))
            {
                var (baseType, _) = GetHighestBaseTypeWithField(node, field.Name);
                if (baseType != null)
                {
                    WriteLine(string.Format("internal override {0} Add{1}{2}Core(params {3}[] items) => Add{1}{2}(items);", baseType.Name, StripPost(field.Name, "Opt"), referencedNodeField.Name, argType));
                    isNew = true;
                }
            }

            // AddBaseListTypes
            Write($"public{(isNew ? " new " : " ")}{node.Name} Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}(params {argType}[] items)");

            if (IsOptional(field))
            {
                WriteLine();
                OpenBlock();
                var factoryName = StripPost(referencedNode.Name, "Syntax");
                var varName = StripPost(CamelCase(field.Name), "Opt");
                WriteLine(string.Format("var {0} = this.{1} ?? SyntaxFactory.{2}();", varName, field.Name, factoryName));
                WriteLine(string.Format("return With{0}({1}.With{2}({1}.{3}.AddRange(items)));", StripPost(field.Name, "Opt"), varName, StripPost(referencedNodeField.Name, "Opt"), referencedNodeField.Name));
                CloseBlock();
            }
            else
            {
                WriteLine(string.Format(" => With{0}(this.{1}.With{2}(this.{1}.{3}.AddRange(items)));", StripPost(field.Name, "Opt"), field.Name, StripPost(referencedNodeField.Name, "Opt"), referencedNodeField.Name));
            }
        }

        private void WriteRedRewriter()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode)).ToList();

            WriteLine();
            WriteLine("public partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<SyntaxNode?>");
            OpenBlock();

            int nWritten = 0;
            foreach (var node in nodes.OfType<Node>())
            {
                if (nWritten > 0)
                    WriteLine();
                nWritten++;
                WriteLine(string.Format("public override SyntaxNode? Visit{0}({1} node)", StripPost(node.Name, "Syntax"), node.Name));

                if (node.Fields.Count == 0)
                {
                    WriteLine("    => node;");
                }
                else
                {
                    Write("    => node.Update(");

                    foreach (var field in node.Fields)
                    {
                        if (field != node.Fields.First())
                        {
                            Write(", ");
                        }

                        if (IsNodeOrNodeList(field.Type))
                        {
                            if (IsAnyList(field.Type))
                            {
                                Write(string.Format("VisitList(node.{1})", CamelCase(field.Name), field.Name));
                            }
                            else if (field.Type == "SyntaxToken")
                            {
                                Write(string.Format("VisitToken(node.{1})", CamelCase(field.Name), field.Name));
                            }
                            else if (IsOptional(field))
                            {
                                Write(string.Format("({1})Visit(node.{2})", CamelCase(field.Name), GetFieldType(field, green: false), field.Name));
                            }
                            else
                            {
                                Write(string.Format("({1})Visit(node.{2}) ?? throw new ArgumentNullException(\"{0}\")", CamelCase(field.Name), GetFieldType(field, green: false), field.Name));
                            }
                        }
                        else
                        {
                            Write(string.Format("node.{0}", field.Name));
                        }
                    }

                    WriteLine(");");
                }
            }
            CloseBlock();
        }

        private void WriteRedFactories()
        {
            var nodes = Tree.Types.Where(n => !(n is PredefinedNode) && !(n is AbstractNode)).OfType<Node>().ToList();
            WriteLine();
            WriteLine("public static partial class SyntaxFactory");
            OpenBlock();

            foreach (var node in nodes)
            {
                this.WriteRedFactory(node);
                bool skipConvenienceFactories = node.SkipConvenienceFactories != null && string.Compare(node.SkipConvenienceFactories, "true", true) == 0;
                if (!skipConvenienceFactories)
                {
                    this.WriteRedFactoryWithNoAutoCreatableTokens(node);
                    this.WriteRedMinimalFactory(node);
                    this.WriteRedMinimalFactory(node, withStringNames: true);
                }
                this.WriteKindConverters(node);
            }

            CloseBlock();
        }

        protected bool CanBeAutoCreated(Node node, Field field)
        {
            return IsAutoCreatableToken(node, field) || IsAutoCreatableNode(node, field);
        }

        private bool IsAutoCreatableToken(Node node, Field field)
        {
            return field.Type == "SyntaxToken"
                && field.Kinds != null
                && ((field.Kinds.Count == 1 && field.Kinds[0].Name != "IdentifierToken" && !field.Kinds[0].Name.EndsWith("LiteralToken", StringComparison.Ordinal)) || (field.Kinds.Count > 1 && field.Kinds.Count == node.Kinds.Count));
        }

        private bool IsAutoCreatableNode(Node node, Field field)
        {
            var referencedNode = GetNode(field.Type);
            return (referencedNode != null && RequiredFactoryArgumentCount(referencedNode) == 0);
        }

        private bool IsRequiredFactoryField(Node node, Field field)
        {
            return (!IsOptional(field) && !IsAnyList(field.Type) && !CanBeAutoCreated(node, field)) || IsValueField(field);
        }

        private bool IsValueField(Field field)
        {
            return !IsNodeOrNodeList(field.Type);
        }

        private int RequiredFactoryArgumentCount(Node nd, bool includeKind = true)
        {
            int count = 0;

            // kind must be specified in factory
            if (nd.Kinds.Count > 1 && includeKind)
            {
                count++;
            }

            foreach (var field in nd.Fields)
            {
                if (IsRequiredFactoryField(nd, field))
                {
                    count++;
                }
            }

            return count;
        }

        private int OptionalFactoryArgumentCount(Node nd)
        {
            int count = 0;
            foreach (var field in nd.Fields)
            {
                if (IsOptional(field) || CanBeAutoCreated(nd, field) || IsAnyList(field.Type))
                {
                    count++;
                }
            }

            return count;
        }

        // full factory signature with nothing optional
        private void WriteRedFactory(Node nd)
        {
            this.WriteLine();

            var valueFields = nd.Fields.Where(n => IsValueField(n)).ToList();
            var nodeFields = nd.Fields.Where(n => !IsValueField(n)).ToList();

            WriteComment($"<summary>Creates a new {nd.Name} instance.</summary>");

            Write(string.Format("{0} static {1} {2}(", "public", nd.Name, StripPost(nd.Name, "Syntax")));
            WriteRedFactoryParameters(nd);

            WriteLine(")");
            OpenBlock();

            // validate kinds
            if (nd.Kinds.Count >= 2)
            {
                WriteLine("switch (kind)");
                OpenBlock();
                foreach (var kind in nd.Kinds)
                {
                    WriteLine(string.Format("case SyntaxKind.{0}:{1}", kind.Name, kind == nd.Kinds.Last() ? " break;" : ""));
                }
                WriteLine("default: throw new ArgumentException(nameof(kind));");
                CloseBlock();
            }

            // validate parameters
            foreach (var field in nodeFields)
            {
                var pname = CamelCase(field.Name);

                if (field.Type == "SyntaxToken")
                {
                    if (field.Kinds != null && field.Kinds.Count > 0)
                    {
                        var kinds = field.Kinds.ToList();
                        if (IsOptional(field))
                        {
                            kinds.Add(new Kind { Name = "None" });
                        }

                        if (kinds.Count == 1)
                        {
                            WriteLine($"if ({pname}.Kind() != SyntaxKind.{kinds[0].Name}) throw new ArgumentException(nameof({pname}));");
                        }
                        else
                        {
                            WriteLine(string.Format("switch ({0}.Kind())", pname));
                            OpenBlock();
                            foreach (var kind in kinds)
                            {
                                WriteLine(string.Format("case SyntaxKind.{0}:{1}", kind.Name, kind == kinds.Last() ? " break;" : ""));
                            }
                            WriteLine(string.Format("default: throw new ArgumentException(nameof({0}));", pname));
                            CloseBlock();
                        }
                    }
                }
                else if (!IsAnyList(field.Type) && !IsOptional(field))
                {
                    WriteLine($"if ({CamelCase(field.Name)} == null) throw new ArgumentNullException(nameof({CamelCase(field.Name)}));");
                }
            }

            Write(string.Format("return ({0})Syntax.InternalSyntax.SyntaxFactory.{1}(", nd.Name, StripPost(nd.Name, "Syntax")));
            if (nd.Kinds.Count > 1)
            {
                Write("kind, ");
            }
            foreach (var field in nodeFields)
            {
                if (field != nodeFields.First())
                    Write(", ");
                if (field.Type == "SyntaxToken")
                {
                    if (IsOptional(field))
                    {
                        Write(string.Format("(Syntax.InternalSyntax.SyntaxToken?){0}.Node", CamelCase(field.Name)));
                    }
                    else
                    {
                        // We know the GreenNode is not null because it gets a type check earlier in the generated method
                        Write(string.Format("(Syntax.InternalSyntax.SyntaxToken){0}.Node!", CamelCase(field.Name)));
                    }
                }
                else if (field.Type == "SyntaxList<SyntaxToken>")
                {
                    Write(string.Format("{0}.Node.ToGreenList<Syntax.InternalSyntax.SyntaxToken>()", CamelCase(field.Name)));
                }
                else if (IsNodeList(field.Type))
                {
                    Write(string.Format("{0}.Node.ToGreenList<Syntax.InternalSyntax.{1}>()", CamelCase(field.Name), GetElementType(field.Type)));
                }
                else if (IsSeparatedNodeList(field.Type))
                {
                    Write(string.Format("{0}.Node.ToGreenSeparatedList<Syntax.InternalSyntax.{1}>()", CamelCase(field.Name), GetElementType(field.Type)));
                }
                else if (field.Type == "SyntaxNodeOrTokenList")
                {
                    Write(string.Format("{0}.Node.ToGreenList<Syntax.InternalSyntax.CSharpSyntaxNode>()", CamelCase(field.Name)));
                }
                else if (IsOptional(field))
                {
                    Write(string.Format("{0} == null ? null : (Syntax.InternalSyntax.{1}){0}.Green", CamelCase(field.Name), field.Type));
                }
                else
                {
                    Write(string.Format("(Syntax.InternalSyntax.{1}){0}.Green", CamelCase(field.Name), field.Type));
                }
            }

            // values are at end
            foreach (var field in valueFields)
            {
                Write(", ");
                Write(CamelCase(field.Name));
            }

            WriteLine(").CreateRed();");
            CloseBlock();
        }

        private void WriteRedFactoryParameters(Node nd)
        {
            if (nd.Kinds.Count > 1)
            {
                Write("SyntaxKind kind, ");
            }

            foreach (var field in nd.Fields)
            {
                if (field != nd.Fields.First())
                    Write(", ");

                Write(string.Format("{0} {1}", this.GetRedPropertyType(field), CamelCase(field.Name)));
            }
        }

        private string GetRedPropertyType(Field field)
        {
            if (field.Type == "SyntaxList<SyntaxToken>")
                return "SyntaxTokenList";
            if (IsOptional(field) && IsNode(field.Type) && field.Type != "SyntaxToken")
                return field.Type + "?";
            return field.Type;
        }

        private string GetDefaultValue(Node nd, Field field)
        {
            System.Diagnostics.Debug.Assert(!IsRequiredFactoryField(nd, field));

            if (IsOptional(field) || IsAnyList(field.Type))
            {
                var type = GetRedPropertyType(field);
                return type == "SyntaxTokenList" ? "default(SyntaxTokenList)" : "default";
            }
            else if (field.Type == "SyntaxToken")
            {
                // auto construct token?
                if (field.Kinds.Count == 1)
                {
                    return $"SyntaxFactory.Token(SyntaxKind.{field.Kinds[0].Name})";
                }
                else
                {
                    return $"SyntaxFactory.Token(Get{StripPost(nd.Name, "Syntax")}{StripPost(field.Name, "Opt")}Kind(kind))";
                }
            }
            else
            {
                var referencedNode = GetNode(field.Type);
                return $"SyntaxFactory.{StripPost(referencedNode.Name, "Syntax")}()";
            }
        }

        // Writes Get<Property>Kind() methods for converting between node kind and member token kinds...
        private void WriteKindConverters(Node nd)
        {
            foreach (var field in nd.Fields)
            {
                if (field.Type == "SyntaxToken" && CanBeAutoCreated(nd, field) && field.Kinds.Count > 1)
                {
                    WriteLine();
                    WriteLine(string.Format("private static SyntaxKind Get{0}{1}Kind(SyntaxKind kind)", StripPost(nd.Name, "Syntax"), StripPost(field.Name, "Opt")));
                    Indent();
                    WriteLine("=> kind switch");
                    OpenBlock();

                    for (int k = 0; k < field.Kinds.Count; k++)
                    {
                        var nKind = nd.Kinds[k];
                        var pKind = field.Kinds[k];
                        WriteLine($"SyntaxKind.{nKind.Name} => SyntaxKind.{pKind.Name},");
                    }

                    WriteLine("_ => throw new ArgumentOutOfRangeException(),");
                    CloseBlock(";");
                    Unindent();
                }
            }
        }

        private IEnumerable<Field> DetermineRedFactoryWithNoAutoCreatableTokenFields(Node nd)
        {
            return nd.Fields.Where(f => !IsAutoCreatableToken(nd, f));
        }

        // creates a factory without auto-creatable token arguments
        private void WriteRedFactoryWithNoAutoCreatableTokens(Node nd)
        {
            var nAutoCreatableTokens = nd.Fields.Count(f => IsAutoCreatableToken(nd, f));
            if (nAutoCreatableTokens == 0)
                return; // already handled by general factory

            var factoryWithNoAutoCreatableTokenFields = new HashSet<Field>(DetermineRedFactoryWithNoAutoCreatableTokenFields(nd));
            var minimalFactoryFields = DetermineMinimalFactoryFields(nd);
            if (minimalFactoryFields != null && factoryWithNoAutoCreatableTokenFields.SetEquals(minimalFactoryFields))
            {
                return; // will be handled in minimal factory case
            }

            this.WriteLine();

            WriteComment($"<summary>Creates a new {nd.Name} instance.</summary>");
            Write(string.Format("{0} static {1} {2}(", "public", nd.Name, StripPost(nd.Name, "Syntax")));

            bool hasPreviousParameter = false;
            if (nd.Kinds.Count > 1)
            {
                Write("SyntaxKind kind");
                hasPreviousParameter = true;
            }

            foreach (var field in nd.Fields)
            {
                if (factoryWithNoAutoCreatableTokenFields.Contains(field))
                {
                    if (hasPreviousParameter)
                        Write(", ");

                    Write(string.Format("{0} {1}", GetRedPropertyType(field), CamelCase(field.Name)));

                    hasPreviousParameter = true;
                }
            }
            WriteLine(")");
            Write(string.Format("    => SyntaxFactory.{0}(", StripPost(nd.Name, "Syntax")));

            bool hasPreviousArgument = false;
            if (nd.Kinds.Count > 1)
            {
                Write("kind");
                hasPreviousArgument = true;
            }

            foreach (var field in nd.Fields)
            {
                if (hasPreviousArgument)
                    Write(", ");

                if (factoryWithNoAutoCreatableTokenFields.Contains(field))
                {
                    // pass supplied parameter on to general factory
                    Write(string.Format("{0}", CamelCase(field.Name)));
                }
                else
                {
                    // pass an auto-created token to the general factory
                    Write(string.Format("{0}", GetDefaultValue(nd, field)));
                }

                hasPreviousArgument = true;
            }

            WriteLine(");");
        }

        private Field DetermineMinimalOptionalField(Node nd)
        {
            // first if there is a single list, then choose the list because it would not have been optional
            int listCount = nd.Fields.Count(f => IsAnyNodeList(f.Type));
            if (listCount == 1)
            {
                return nd.Fields.First(f => IsAnyNodeList(f.Type));
            }
            else
            {
                // otherwise, if there is a single optional node, use that..
                int nodeCount = nd.Fields.Count(f => IsNode(f.Type) && f.Type != "SyntaxToken");
                if (nodeCount == 1)
                {
                    return nd.Fields.First(f => IsNode(f.Type) && f.Type != "SyntaxToken");
                }
                else
                {
                    return null;
                }
            }
        }

        private IEnumerable<Field> DetermineMinimalFactoryFields(Node nd)
        {
            // special case to allow a single optional argument if there would have been no arguments
            // and we can determine a best single argument.
            Field allowOptionalField = null;

            var optionalCount = OptionalFactoryArgumentCount(nd);
            if (optionalCount == 0)
            {
                return null; // no fields...
            }

            var requiredCount = RequiredFactoryArgumentCount(nd, includeKind: false);
            if (requiredCount == 0 && optionalCount > 1)
            {
                allowOptionalField = DetermineMinimalOptionalField(nd);
            }

            return nd.Fields.Where(f => IsRequiredFactoryField(nd, f) || allowOptionalField == f);
        }

        // creates a factory with only the required arguments (everything else is defaulted)
        private void WriteRedMinimalFactory(Node nd, bool withStringNames = false)
        {
            var optionalCount = OptionalFactoryArgumentCount(nd);
            if (optionalCount == 0)
                return; // already handled w/ general factory method

            var minimalFactoryfields = new HashSet<Field>(DetermineMinimalFactoryFields(nd));

            if (withStringNames && minimalFactoryfields.Count(f => IsRequiredFactoryField(nd, f) && CanAutoConvertFromString(f)) == 0)
                return; // no string-name overload necessary

            this.WriteLine();

            WriteComment($"<summary>Creates a new {nd.Name} instance.</summary>");
            Write(string.Format("{0} static {1} {2}(", "public", nd.Name, StripPost(nd.Name, "Syntax")));

            bool hasPreviousParameter = false;
            if (nd.Kinds.Count > 1)
            {
                Write("SyntaxKind kind");
                hasPreviousParameter = true;
            }

            foreach (var field in nd.Fields)
            {
                if (minimalFactoryfields.Contains(field))
                {
                    var type = GetRedPropertyType(field);

                    if (IsRequiredFactoryField(nd, field))
                    {
                        if (hasPreviousParameter)
                            Write(", ");

                        if (withStringNames && CanAutoConvertFromString(field))
                        {
                            type = "string";
                        }

                        Write(string.Format("{0} {1}", type, CamelCase(field.Name)));

                        hasPreviousParameter = true;
                    }
                    else
                    {
                        if (hasPreviousParameter)
                            Write(", ");

                        if (IsNode(field.Type) && !IsOptional(field) && field.Type != "SyntaxToken")
                        {
                            type += "?";
                        }

                        Write(string.Format("{0} {1} = default", type, CamelCase(field.Name)));

                        hasPreviousParameter = true;
                    }
                }
            }
            WriteLine(")");

            Write(string.Format("    => SyntaxFactory.{0}(", StripPost(nd.Name, "Syntax")));

            bool hasPreviousArgument = false;
            if (nd.Kinds.Count > 1)
            {
                Write("kind");
                hasPreviousArgument = true;
            }

            foreach (var field in nd.Fields)
            {
                if (hasPreviousArgument)
                    Write(", ");

                if (minimalFactoryfields.Contains(field))
                {
                    if (IsRequiredFactoryField(nd, field))
                    {
                        if (withStringNames && CanAutoConvertFromString(field))
                        {
                            Write(string.Format("{0}({1})", GetStringConverterMethod(field), CamelCase(field.Name)));
                        }
                        else
                        {
                            Write(string.Format("{0}", CamelCase(field.Name)));
                        }
                    }
                    else
                    {
                        if (IsOptional(field) || IsAnyList(field.Type))
                        {
                            Write(string.Format("{0}", CamelCase(field.Name)));
                        }
                        else
                        {
                            Write(string.Format("{0} ?? {1}", CamelCase(field.Name), GetDefaultValue(nd, field)));
                        }
                    }
                }
                else
                {
                    var defaultValue = GetDefaultValue(nd, field);
                    Write(defaultValue);
                }

                hasPreviousArgument = true;
            }

            WriteLine(");");
        }

        private bool CanAutoConvertFromString(Field field)
        {
            return IsIdentifierToken(field) || IsIdentifierNameSyntax(field);
        }

        private bool IsIdentifierToken(Field field)
        {
            return field.Type == "SyntaxToken" && field.Kinds != null && field.Kinds.Count == 1 && field.Kinds[0].Name == "IdentifierToken";
        }

        private bool IsIdentifierNameSyntax(Field field)
        {
            return field.Type == "IdentifierNameSyntax";
        }

        private string GetStringConverterMethod(Field field)
        {
            if (IsIdentifierToken(field))
            {
                return "SyntaxFactory.Identifier";
            }
            else if (IsIdentifierNameSyntax(field))
            {
                return "SyntaxFactory.IdentifierName";
            }
            else
            {
                throw new NotSupportedException();
            }
        }

        /// <summary>
        /// Anything inside a &lt;Comment&gt; tag gets written out (escaping untouched) as the
        /// XML doc comment.  Line breaks will be preserved.
        /// </summary>
        private void WriteComment(string comment)
        {
            if (comment != null)
            {
                var lines = comment.Split(new string[] { "\r", "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
                {
                    WriteLine(string.Format("{0}/// {1}", "", line.TrimStart()));
                }
            }
        }

        /// <summary>
        /// Anything inside a &lt;Comment&gt; tag gets written out (escaping untouched) as the
        /// XML doc comment.  Line breaks will be preserved.
        /// </summary>
        private void WriteComment(Comment comment, string indent)
        {
            if (comment != null)
            {
                foreach (XmlElement element in comment.Body)
                {
                    string[] lines = element.OuterXml.Split(new string[] { "\r", "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                    foreach (string line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
                    {
                        WriteLine(string.Format("{0}/// {1}", indent, line.TrimStart()));
                    }
                }
            }
        }
    }
}
