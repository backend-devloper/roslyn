// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Scripting.Emit;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.Scripting
{
    /// <summary>
    /// Represents a runtime execution context for C# scripts.
    /// </summary>
    internal class ScriptBuilder
    {
        /// <summary>
        /// Unique prefix for generated uncollectible assemblies.
        /// </summary>
        /// <remarks>
        /// The full names of uncollectible assemblies generated by this context must be unique,
        /// so that we can resolve references among them. Note that CLR can load two different assemblies of the very 
        /// identity into the same load context.
        /// 
        /// We are using a certain naming scheme for the generated assemblies (a fixed name prefix followed by a number). 
        /// If we allowed the compiled code to add references that match this exact pattern it might happen that 
        /// the user supplied reference identity conflicts with the identity we use for our generated assemblies and 
        /// the AppDomain assembly resolve event won't be able to correctly identify the target assembly.
        /// 
        /// To avoid this problem we use a prefix for assemblies we generate that is unlikely to conflict with user specified references.
        /// We also check that no user provided references are allowed to be used in the compiled code and report an error ("reserved assembly name").
        /// </remarks>
        private static readonly string s_globalAssemblyNamePrefix;
        private static int s_engineIdDispenser;
        private int _submissionIdDispenser = -1;
        private readonly string _assemblyNamePrefix;

        private readonly UncollectibleCodeManager _uncollectibleCodeManager;

        /// <summary>
        /// Lockable object only instance is knowledgeable about.
        /// </summary>
        private readonly object _gate = new object();

        #region Testing and Debugging

        private const string UncollectibleModuleFileName = "UncollectibleModule.dll";

        // Setting this flag will add DebuggableAttribute on the emitted code that disables JIT optimizations.
        // With optimizations disabled JIT will verify the method before it compiles it so we can easily 
        // discover incorrect code.
        internal static bool DisableJitOptimizations;

        #endregion

        static ScriptBuilder()
        {
            s_globalAssemblyNamePrefix = "\u211B*" + Guid.NewGuid().ToString() + "-";
        }

        public ScriptBuilder(AssemblyLoader assemblyLoader = null)
        {
            if (assemblyLoader == null)
            {
                assemblyLoader = new InteractiveAssemblyLoader();
            }

            _assemblyNamePrefix = s_globalAssemblyNamePrefix + "#" + Interlocked.Increment(ref s_engineIdDispenser).ToString();
            _uncollectibleCodeManager = new UncollectibleCodeManager(assemblyLoader, _assemblyNamePrefix);
        }

        internal string AssemblyNamePrefix
        {
            get { return _assemblyNamePrefix; }
        }

        internal static bool IsReservedAssemblyName(AssemblyIdentity identity)
        {
            return identity.Name.StartsWith(s_globalAssemblyNamePrefix, StringComparison.Ordinal);
        }

        public int GenerateSubmissionId(out string assemblyName, out string typeName)
        {
            int id = Interlocked.Increment(ref _submissionIdDispenser);
            string idAsString = id.ToString();
            assemblyName = _assemblyNamePrefix + idAsString;
            typeName = "Submission#" + idAsString;
            return id;
        }

        /// <summary>
        /// Builds a delegate that will execute just this scripts code.
        /// </summary>
        public Func<object[], object> Build(
            Script script,
            DiagnosticBag diagnostics,
            CancellationToken cancellationToken)
        {
            var compilation = script.GetCompilation();
            var options = script.Options;

            DiagnosticBag emitDiagnostics = DiagnosticBag.GetInstance();
            byte[] compiledAssemblyImage;

            string entryPointTypeName;
            string entryPointMethodName;

            bool success = compilation.Emit(
                emitDiagnostics,
                out entryPointTypeName,
                out entryPointMethodName,
                out compiledAssemblyImage,
                cancellationToken);

            if (diagnostics != null)
            {
                diagnostics.AddRange(emitDiagnostics);
            }

            bool hadEmitErrors = emitDiagnostics.HasAnyErrors();
            emitDiagnostics.Free();

            // emit can fail due to compilation errors or because there is nothing to emit:
            if (!success)
            {
                return null;
            }

            Debug.Assert(compiledAssemblyImage != null);

            // TODO: do not actually load the assemblies, only notify the loader of mapping from AssemblyIdentity to location.
            foreach (var referencedAssembly in compilation.GetBoundReferenceManager().GetReferencedAssemblies())
            {
                _uncollectibleCodeManager.Load(
                    identity: referencedAssembly.Value.Identity,
                    location: (referencedAssembly.Key as PortableExecutableReference)?.FilePath);
            }

            var assembly = Assembly.Load(compiledAssemblyImage);
            _uncollectibleCodeManager.AddFallBackAssembly(assembly);

            var entryPointType = assembly.GetType(entryPointTypeName, throwOnError: true, ignoreCase: false).GetTypeInfo();
            var entryPointMethod = entryPointType.GetDeclaredMethod(entryPointMethodName);
            return entryPointMethod.CreateDelegate<Func<object[], object>>();
        }

        /// <summary>
        /// Resolves assembly references from CCI generated metadata. 
        /// The resolution is triggered by the CLR Type Loader.
        /// </summary>
        private sealed class UncollectibleCodeManager : AssemblyLoader
        {
            private readonly AssemblyLoader _assemblyLoader;
            private readonly string _assemblyNamePrefix;

            // lock(_gate) on access
            private HashSet<Assembly> _fallBackAssemblies; // additional uncollectible assemblies created due to a Ref.Emit falling back to CCI
            private Dictionary<string, Assembly> _mapping; // { simple name -> fall-back assembly }

            /// <summary>
            /// Lockable object only instance is knowledgeable about.
            /// </summary>
            private readonly object _gate = new object();

            internal UncollectibleCodeManager(AssemblyLoader assemblyLoader, string assemblyNamePrefix)
            {
                _assemblyLoader = assemblyLoader;
                _assemblyNamePrefix = assemblyNamePrefix;

                AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(Resolve);
            }

            internal void AddFallBackAssembly(Assembly assembly)
            {
                lock (_gate)
                {
                    if (_fallBackAssemblies == null)
                    {
                        Debug.Assert(_mapping == null);
                        _fallBackAssemblies = new HashSet<Assembly>();
                        _mapping = new Dictionary<string, Assembly>();
                    }

                    _fallBackAssemblies.Add(assembly);
                    _mapping[assembly.GetName().Name] = assembly;
                }
            }

            private Assembly Resolve(object sender, ResolveEventArgs args)
            {
                if (!args.Name.StartsWith(_assemblyNamePrefix, StringComparison.Ordinal))
                {
                    return null;
                }

                lock (_gate)
                {
                    if (_fallBackAssemblies != null && _fallBackAssemblies.Contains(args.RequestingAssembly))
                    {
                        int comma = args.Name.IndexOf(',');
                        return ResolveNoLock(args.Name.Substring(0, (comma != -1) ? comma : args.Name.Length));
                    }
                }

                return null;
            }

            private Assembly Resolve(string simpleName)
            {
                lock (_gate)
                {
                    return ResolveNoLock(simpleName);
                }
            }

            private Assembly ResolveNoLock(string simpleName)
            {
                Assembly assembly;
                if (_mapping != null && _mapping.TryGetValue(simpleName, out assembly))
                {
                    return assembly;
                }

                return null;
            }

            public override Assembly Load(AssemblyIdentity identity, string location = null)
            {
                return Resolve(identity.Name) ?? _assemblyLoader.Load(identity, location);
            }
        }
    }
}
